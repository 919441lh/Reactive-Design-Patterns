{"docs":[{"location":"/index.html","text":"目录 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业主流工具 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——原则化的失败处理 第8章——有限定的一致性 第9章——按需的不确定性 第10章——消息流 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言\n《反应式设计模式》\n原书名《Reactive Design Patterns》\n一本有关反应式（Reactive）应用程序的模式书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#代码清单2-1","text":"Listing 2.1 Excerpt from a simple controller for an image service\npublic interface Images {\n    Image get(String Key);\n    void add(String key, Image image);\n}\n\npublic Images cache;\npublic Images database;\n\npublic Image retrieveImages(String key){\n    Image result = cache.get(key);\n    if (result != null) {\n        return result;\n    } else {\n        result = database.get(key);\n        if (result != null) {\n            cache.add(key, result);\n            return result;\n        } else {\n            return fallback;\n        }\n    }\n}","title":"代码清单2-1"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业主流工具 ·"},{"location":"/chapter-03/index.html#第3章-行业主流工具","text":"","title":"第3章——行业主流工具"},{"location":"/chapter-03/index.html#可用性-99-9999999-","text":"3.1536 seconds of downtime in 100 years\n100 years\n    * 365 days/year\n    * 24 hours/day\n    * 60 minutes/hour\n    * 60 seconds/minute\n        = 3,153,600,000 seconds\n        \n3,153,600,000 seconds\n    * 0.000000001 expected downtime\n        = 3.1536 seconds of downtime in 100 years","title":"可用性 99.9999999%"},{"location":"/chapter-03/index.html#代码清单3-1","text":"Listing 3.1 Unsafe, mutable message class, which may hide unexpected behavior\nimport java.util.Date;\n\npublic class Unsafe {\n    private Date timestamp;\n    private final StringBuffer message;\n    public Unsafe(Date timestamp, StringBuffer message) {\n        this.timestamp = timestamp;\n        this.message = message;\n    }\n    public synchronized Date getTimestamp() {\n        return timestamp;\n    }\n    public synchronized void setTimestamp(Date timestamp) {\n        this.timestamp = timestamp;\n    }\n    public StringBuffer getMessage() {\n        return message;\n    }\n}","title":"代码清单3-1"},{"location":"/chapter-03/index.html#代码清单3-2","text":"Listing 3.2 Immutable message class that behaves predictably and is easier to reason about\nimport java.util.Date;\n\npublic class Immutable {\n    private final Date timestamp;\n    private final String message;\n    public Immutable(final Date timestamp, final String message) {\n        this.timestamp = new Date(timestamp.getTime());\n        this.message = message;\n    }\n    public Date getTimestamp() {\n        return new Date(timestamp.getTime());\n    }\n    public String getMessage() {\n        return message;\n    }\n}","title":"代码清单3-2"},{"location":"/chapter-03/index.html#代码清单3-3","text":"使用Scala的case class定义的不可变消息\nimport java.util.Date\n\ncase class Message(timestamp: Date, message: String)","title":"代码清单3-3"},{"location":"/chapter-03/index.html#代码清单3-4","text":"引用不透明\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\n        \"original '%s', new value '%s'\",\n        original,\n        reversed));","title":"代码清单3-4"},{"location":"/chapter-03/index.html#代码清单3-5","text":"引用透明\nReferential transparency: allowing substitution of precomputed values\npublic class Rooter {\n    private final double value;\n    private Double root = null;\n    public Rooter(double value) {\n        this.value = value;\n    }\n    public double getValue() {\n        return value;\n    }\n    public double getRoot() {\n        if (root == null) {\n            root = Math.sqrt(value);\n        }\n        return root;\n    }\n}","title":"代码清单3-5"},{"location":"/chapter-03/index.html#代码清单3-6","text":"Limiting usability with side effects\npublic class SideEffecting implements Serializable, Cloneable {\n    private int count;\n    public SideEffecting(int start) {\n        this.count = start;\n    }\n    public int next() {\n        this.count += Math.incrementExact(this.count);\n        return this.count;\n    }\n}","title":"代码清单3-6"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——原则化的失败处理 ·"},{"location":"/chapter-07/index.html#第7章-原则化的失败处理","text":"","title":"第7章——原则化的失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有限定的一致性 ·"},{"location":"/chapter-08/index.html#第8章-有限定的一致性","text":"","title":"第8章——有限定的一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需的不确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需的不确定性","text":"","title":"第9章——按需的不确定性"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"","title":"第10章——消息流"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"","title":"第12章——容错及恢复模式"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"","title":"第14章——资源管理模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"","title":"第15章——消息流模式"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"","title":"第16章——流控制模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"","title":"第17章——状态管理和持久化模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"}]}