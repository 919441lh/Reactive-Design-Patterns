{"docs":[{"location":"/index.html","text":"目录 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业主流工具 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——原则化的失败处理 第8章——有限定的一致性 第9章——按需的不确定性 第10章——消息流 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言\n《反应式设计模式》\n原书名《Reactive Design Patterns》\n一本有关反应式（Reactive）应用程序的模式书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#代码清单2-1","text":"Listing 2.1 Excerpt from a simple controller for an image service\npublic interface Images {\n    Image get(String Key);\n    void add(String key, Image image);\n}\n\npublic Images cache;\npublic Images database;\n\npublic Image retrieveImages(String key){\n    Image result = cache.get(key);\n    if (result != null) {\n        return result;\n    } else {\n        result = database.get(key);\n        if (result != null) {\n            cache.add(key, result);\n            return result;\n        } else {\n            return fallback;\n        }\n    }\n}","title":"代码清单2-1"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业主流工具 ·"},{"location":"/chapter-03/index.html#第3章-行业主流工具","text":"","title":"第3章——行业主流工具"},{"location":"/chapter-03/index.html#可用性-99-9999999-","text":"3.1536 seconds of downtime in 100 years\n100 years\n    * 365 days/year\n    * 24 hours/day\n    * 60 minutes/hour\n    * 60 seconds/minute\n        = 3,153,600,000 seconds\n        \n3,153,600,000 seconds\n    * 0.000000001 expected downtime\n        = 3.1536 seconds of downtime in 100 years","title":"可用性 99.9999999%"},{"location":"/chapter-03/index.html#代码清单3-1","text":"Listing 3.1 Unsafe, mutable message class, which may hide unexpected behavior\nimport java.util.Date;\n\npublic class Unsafe {\n    private Date timestamp;\n    private final StringBuffer message;\n    public Unsafe(Date timestamp, StringBuffer message) {\n        this.timestamp = timestamp;\n        this.message = message;\n    }\n    public synchronized Date getTimestamp() {\n        return timestamp;\n    }\n    public synchronized void setTimestamp(Date timestamp) {\n        this.timestamp = timestamp;\n    }\n    public StringBuffer getMessage() {\n        return message;\n    }\n}","title":"代码清单3-1"},{"location":"/chapter-03/index.html#代码清单3-2","text":"Listing 3.2 Immutable message class that behaves predictably and is easier to reason about\nimport java.util.Date;\n\npublic class Immutable {\n    private final Date timestamp;\n    private final String message;\n    public Immutable(final Date timestamp, final String message) {\n        this.timestamp = new Date(timestamp.getTime());\n        this.message = message;\n    }\n    public Date getTimestamp() {\n        return new Date(timestamp.getTime());\n    }\n    public String getMessage() {\n        return message;\n    }\n}","title":"代码清单3-2"},{"location":"/chapter-03/index.html#代码清单3-3","text":"使用Scala的case class定义的不可变消息\nimport java.util.Date\n\ncase class Message(timestamp: Date, message: String)","title":"代码清单3-3"},{"location":"/chapter-03/index.html#代码清单3-4","text":"引用不透明\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\n        \"original '%s', new value '%s'\",\n        original,\n        reversed));","title":"代码清单3-4"},{"location":"/chapter-03/index.html#代码清单3-5","text":"引用透明\nReferential transparency: allowing substitution of precomputed values\npublic class Rooter {\n    private final double value;\n    private Double root = null;\n    public Rooter(double value) {\n        this.value = value;\n    }\n    public double getValue() {\n        return value;\n    }\n    public double getRoot() {\n        if (root == null) {\n            root = Math.sqrt(value);\n        }\n        return root;\n    }\n}","title":"代码清单3-5"},{"location":"/chapter-03/index.html#代码清单3-6","text":"Limiting usability with side effects\npublic class SideEffecting implements Serializable, Cloneable {\n    private int count;\n    public SideEffecting(int start) {\n        this.count = start;\n    }\n    public int next() {\n        this.count += Math.incrementExact(this.count);\n        return this.count;\n    }\n}","title":"代码清单3-6"},{"location":"/chapter-03/index.html#代码清单3-7","text":"final int next = se.next();\nif (logger.isDebugEnabled()) {\n    logger.debug(\"Next is \" + se.next());\n}\nreturn next;","title":"代码清单3-7"},{"location":"/chapter-03/index.html#代码清单3-8","text":"final List<Integer> numbers = Arrays.asList(1, 2, 3);\nfinal List<Integer> numbersPlusOne =\n        numbers.stream()\n                .map(number -> number + 1)\n                .collect(Collectors.toList());","title":"代码清单3-8"},{"location":"/chapter-03/index.html#python-repl-3-1","text":">>> def addOne(x):\n... returnx+1\n...\n>>> myFunction = addOne\n>>> myFunction(3)\n4","title":"Python REPL 3-1"},{"location":"/chapter-03/index.html#代码清单3-9","text":"var http = require('http');\n\nvar counter = 0;\n\nhttp.createServer(function (req, res) {\n  counter++;\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Sending response: ' + counter + ' via callback!\\n');\n}).listen(8888, '127.0.0.1');\n\nconsole.log('Server up on 127.0.0.1:8888, send requests!');","title":"代码清单3-9"},{"location":"/chapter-03/index.html#代码清单3-10","text":"package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\titerations := 10\n    myChannel := make(chan int)\n\n    go producer(myChannel, iterations)\n    go consumer(myChannel, iterations)\n\n    time.Sleep(500 * time.Millisecond)\n}\n\nfunc producer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        fmt.Println(\"Sending: \", i)\n        myChannel <- i\n    }   \n}\n\nfunc consumer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        recVal := <-myChannel\n        fmt.Println(\"Received: \", recVal)\n    }   \n}","title":"代码清单3-10"},{"location":"/chapter-03/index.html#代码清单3-11","text":"public class ParallelRetrievalExample {\n    private final CacheRetriever cacheRetriever;\n    private final DBRetriever dbRetriever;\n\n    ParallelRetrievalExample(CacheRetriever cacheRetriever,\n                             DBRetriever dbRetriever) {\n        this.cacheRetriever = cacheRetriever;\n        this.dbRetriever = dbRetriever;\n    }\n\n    public Object retrieveCustomer(final long id) {\n        final CompletableFuture<Object> cacheFuture = CompletableFuture\n                .supplyAsync(() -> cacheRetriever.getCustomer(id));\n        final CompletableFuture<Object> dbFuture = CompletableFuture\n                .supplyAsync(() -> dbRetriever.getCustomer(id));\n\n        return CompletableFuture.anyOf(cacheFuture, dbFuture);\n    }\n}","title":"代码清单3-11"},{"location":"/chapter-03/index.html#代码清单3-12","text":"def getProductInventoryByPostalCode(\n  productSku: Long,\n  postalCode: String): Future[(Long, Map[String, Long])] = {\n  // Import the duration DSL to be used in the timeout\n  import scala.concurrent.duration._\n\n  // Provide the thread pool and Future timeout value to be applied\n  implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(new ForkJoinPool())\n  implicit val timeout: FiniteDuration = 250 milliseconds\n\n  // Define the futures so they can start doing their work\n  val localInventoryFuture = Future {\n    inventoryService.currentInventoryInWarehouse(\n      productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = Future {\n    inventoryService.currentInventoryOverallByWarehouse(\n      productSku)\n  }\n\n  // Retrieve the values and return a future of the combined result\n  for {\n    local ← localInventoryFuture\n    overall ← overallInventoryFutureByWarehouse\n  } yield (local, overall)\n}","title":"代码清单3-12"},{"location":"/chapter-03/index.html#代码清单3-13","text":"import scala.async.Async.{ async, await }\nval resultFuture = async {\n  val localInventoryFuture = async {\n    inventoryService.currentInventoryInWarehouse(productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = async {\n    inventoryService.currentInventoryOverallByWarehouse(productSku)\n  }\n  (await(localInventoryFuture), await(overallInventoryFutureByWarehouse))\n}","title":"代码清单3-13"},{"location":"/chapter-03/index.html#代码清单3-14","text":"package chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n    public void observe(String[] strings) {\n        Observable.fromArray(strings).subscribe((s) -> {\n                System.out.println(\"Received \" + s);\n        });\n    }\n}","title":"代码清单3-14"},{"location":"/chapter-03/index.html#代码清单3-15","text":"package chapter03.rxjava;\n\npublic class RxJavaExampleDriver {\n    private static final RxJavaExample rxJavaExample = new RxJavaExample();\n    public static void main(String[] args) {\n        String[] strings = { \"a\", \"b\", \"c\" };\n        rxJavaExample.observe(strings);\n    }\n}","title":"代码清单3-15"},{"location":"/chapter-03/index.html#代码清单3-16","text":"package chapter03.actor\n\nimport akka.actor._\nimport akka.actor.SupervisorStrategy.Restart\nimport akka.event.LoggingReceive\n\ncase object Start\ncase class CounterMessage(counterValue: Int)\ncase class CounterTooLargeException(message: String) extends Exception(message)\n\nclass SupervisorActor extends Actor with ActorLogging {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: CounterTooLargeException ⇒ Restart\n  }\n\n  private val actor2 = context.actorOf(Props[SecondActor], \"second-actor\")\n  private val actor1 = context.actorOf(Props(new FirstActor(actor2)), \"first-actor\")\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Start ⇒ actor1 ! Start\n  }\n}\n\nclass AbstractCounterActor extends Actor with ActorLogging {\n  protected var counterValue = 0\n\n  def receive: PartialFunction[Any, Unit] = {\n    case _ ⇒\n  }\n\n  def counterReceive: Receive = LoggingReceive {\n    case CounterMessage(i) if i <= 1000 ⇒\n      counterValue = i\n      log.info(s\"Counter value: $counterValue\")\n      sender ! CounterMessage(counterValue + 1)\n    case CounterMessage(_) ⇒\n      throw CounterTooLargeException(\n        \"Exceeded max value of counter!\")\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    context.parent ! Start\n  }\n}\n\nclass FirstActor(secondActor: ActorRef) extends AbstractCounterActor {\n  override def receive = LoggingReceive {\n    case Start ⇒\n      context.become(counterReceive)\n      log.info(\"Starting counter passing.\")\n      secondActor ! CounterMessage(counterValue + 1)\n  }\n}\n\nclass SecondActor() extends AbstractCounterActor {\n  override def receive: Receive = counterReceive\n}\n\nobject Example extends App {\n  val system = ActorSystem(\"counter-supervision-example\")\n  val supervisor = system.actorOf(Props[SupervisorActor])\n  supervisor ! Start\n}","title":"代码清单3-16"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——原则化的失败处理 ·"},{"location":"/chapter-07/index.html#第7章-原则化的失败处理","text":"","title":"第7章——原则化的失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有限定的一致性 ·"},{"location":"/chapter-08/index.html#第8章-有限定的一致性","text":"","title":"第8章——有限定的一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需的不确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需的不确定性","text":"","title":"第9章——按需的不确定性"},{"location":"/chapter-09/index.html#数学函数","text":"f(x) = x + 1\ng(x) = x - 1\nh(x) = f(x) - g(x)","title":"数学函数"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"","title":"第10章——消息流"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"","title":"第12章——容错及恢复模式"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"","title":"第14章——资源管理模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"","title":"第15章——消息流模式"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"","title":"第16章——流控制模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"","title":"第17章——状态管理和持久化模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"}]}