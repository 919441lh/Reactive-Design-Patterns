{"docs":[{"location":"/index.html","text":"目录 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业主流工具 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——原则化的失败处理 第8章——有限定的一致性 第9章——按需的不确定性 第10章——消息流 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言\n《反应式设计模式》\n原书名《Reactive Design Patterns》\n一本有关反应式（Reactive）应用程序的模式书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#代码清单2-1","text":"Listing 2.1 Excerpt from a simple controller for an image service\npublic interface Images {\n    Image get(String Key);\n    void add(String key, Image image);\n}\n\npublic Images cache;\npublic Images database;\n\npublic Image retrieveImages(String key){\n    Image result = cache.get(key);\n    if (result != null) {\n        return result;\n    } else {\n        result = database.get(key);\n        if (result != null) {\n            cache.add(key, result);\n            return result;\n        } else {\n            return fallback;\n        }\n    }\n}","title":"代码清单2-1"},{"location":"/chapter-02/index.html#代码清单2-2","text":"val result = f(42)","title":"代码清单2-2"},{"location":"/chapter-02/index.html#代码清单2-3","text":"ReplyA a = computeA();\nReplyB b = computeB();\nReplyC c = computeC();\n\nResult r = aggregate(a, b, c);","title":"代码清单2-3"},{"location":"/chapter-02/index.html#代码清单2-4","text":"Future<ReplyA> a = taskA();\nFuture<ReplyB> b = taskB();\nFuture<ReplyC> c = taskC();\n\nResult r = aggregate(a.get(), b.get(), c.get());","title":"代码清单2-4"},{"location":"/chapter-02/index.html#代码清单2-5","text":"val fa: Future[ReplyA] = taskA()\nval fb: Future[ReplyB] = taskB()\nval fc: Future[ReplyC] = taskC()\n\nval fr: Future[Result] = for (a ← fa; b ← fb; c ← fc)\n  yield aggregate(a, b, c)","title":"代码清单2-5"},{"location":"/chapter-02/index.html#代码清单2-6","text":"final Socket socket = new Socket(\"127.0.0.1\",8080);\nsocket.getOutputStream().write(requestMessageBytes);\nfinal int bytesRead = socket.getInputStream().read(responseBuffer);","title":"代码清单2-6"},{"location":"/chapter-02/index.html#代码清单2-7","text":"CompletionStage<Response> future =\n        ask(actorRef, request, timeout)\n                .thenApply(Response.class::cast);\nfuture.thenAccept(response -> AskActorWithJava8.processIt(response));","title":"代码清单2-7"},{"location":"/chapter-02/index.html#代码清单2-8","text":"try {\n  f(i)\n} catch {\n  case _: java.lang.ArithmeticException ⇒ Int.MaxValue\n  case ex: java.lang.StackOverflowError ⇒ ???\n  case ex: java.net.ConnectException    ⇒ ???\n}","title":"代码清单2-8"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业主流工具 ·"},{"location":"/chapter-03/index.html#第3章-行业主流工具","text":"","title":"第3章——行业主流工具"},{"location":"/chapter-03/index.html#可用性-99-9999999-","text":"3.1536 seconds of downtime in 100 years\n100 years\n    * 365 days/year\n    * 24 hours/day\n    * 60 minutes/hour\n    * 60 seconds/minute\n        = 3,153,600,000 seconds\n        \n3,153,600,000 seconds\n    * 0.000000001 expected downtime\n        = 3.1536 seconds of downtime in 100 years","title":"可用性 99.9999999%"},{"location":"/chapter-03/index.html#代码清单3-1","text":"Listing 3.1 Unsafe, mutable message class, which may hide unexpected behavior\nimport java.util.Date;\n\npublic class Unsafe {\n    private Date timestamp;\n    private final StringBuffer message;\n    public Unsafe(Date timestamp, StringBuffer message) {\n        this.timestamp = timestamp;\n        this.message = message;\n    }\n    public synchronized Date getTimestamp() {\n        return timestamp;\n    }\n    public synchronized void setTimestamp(Date timestamp) {\n        this.timestamp = timestamp;\n    }\n    public StringBuffer getMessage() {\n        return message;\n    }\n}","title":"代码清单3-1"},{"location":"/chapter-03/index.html#代码清单3-2","text":"Listing 3.2 Immutable message class that behaves predictably and is easier to reason about\nimport java.util.Date;\n\npublic class Immutable {\n    private final Date timestamp;\n    private final String message;\n    public Immutable(final Date timestamp, final String message) {\n        this.timestamp = new Date(timestamp.getTime());\n        this.message = message;\n    }\n    public Date getTimestamp() {\n        return new Date(timestamp.getTime());\n    }\n    public String getMessage() {\n        return message;\n    }\n}","title":"代码清单3-2"},{"location":"/chapter-03/index.html#代码清单3-3","text":"使用Scala的case class定义的不可变消息\nimport java.util.Date\n\ncase class Message(timestamp: Date, message: String)","title":"代码清单3-3"},{"location":"/chapter-03/index.html#代码清单3-4","text":"引用不透明\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\n        \"original '%s', new value '%s'\",\n        original,\n        reversed));","title":"代码清单3-4"},{"location":"/chapter-03/index.html#代码清单3-5","text":"引用透明\nReferential transparency: allowing substitution of precomputed values\npublic class Rooter {\n    private final double value;\n    private Double root = null;\n    public Rooter(double value) {\n        this.value = value;\n    }\n    public double getValue() {\n        return value;\n    }\n    public double getRoot() {\n        if (root == null) {\n            root = Math.sqrt(value);\n        }\n        return root;\n    }\n}","title":"代码清单3-5"},{"location":"/chapter-03/index.html#代码清单3-6","text":"Limiting usability with side effects\npublic class SideEffecting implements Serializable, Cloneable {\n    private int count;\n    public SideEffecting(int start) {\n        this.count = start;\n    }\n    public int next() {\n        this.count += Math.incrementExact(this.count);\n        return this.count;\n    }\n}","title":"代码清单3-6"},{"location":"/chapter-03/index.html#代码清单3-7","text":"final int next = se.next();\nif (logger.isDebugEnabled()) {\n    logger.debug(\"Next is \" + se.next());\n}\nreturn next;","title":"代码清单3-7"},{"location":"/chapter-03/index.html#代码清单3-8","text":"final List<Integer> numbers = Arrays.asList(1, 2, 3);\nfinal List<Integer> numbersPlusOne =\n        numbers.stream()\n                .map(number -> number + 1)\n                .collect(Collectors.toList());","title":"代码清单3-8"},{"location":"/chapter-03/index.html#python-repl-3-1","text":">>> def addOne(x):\n... returnx+1\n...\n>>> myFunction = addOne\n>>> myFunction(3)\n4","title":"Python REPL 3-1"},{"location":"/chapter-03/index.html#代码清单3-9","text":"var http = require('http');\n\nvar counter = 0;\n\nhttp.createServer(function (req, res) {\n  counter++;\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Sending response: ' + counter + ' via callback!\\n');\n}).listen(8888, '127.0.0.1');\n\nconsole.log('Server up on 127.0.0.1:8888, send requests!');","title":"代码清单3-9"},{"location":"/chapter-03/index.html#代码清单3-10","text":"package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\titerations := 10\n    myChannel := make(chan int)\n\n    go producer(myChannel, iterations)\n    go consumer(myChannel, iterations)\n\n    time.Sleep(500 * time.Millisecond)\n}\n\nfunc producer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        fmt.Println(\"Sending: \", i)\n        myChannel <- i\n    }   \n}\n\nfunc consumer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        recVal := <-myChannel\n        fmt.Println(\"Received: \", recVal)\n    }   \n}","title":"代码清单3-10"},{"location":"/chapter-03/index.html#代码清单3-11","text":"public class ParallelRetrievalExample {\n    private final CacheRetriever cacheRetriever;\n    private final DBRetriever dbRetriever;\n\n    ParallelRetrievalExample(CacheRetriever cacheRetriever,\n                             DBRetriever dbRetriever) {\n        this.cacheRetriever = cacheRetriever;\n        this.dbRetriever = dbRetriever;\n    }\n\n    public Object retrieveCustomer(final long id) {\n        final CompletableFuture<Object> cacheFuture = CompletableFuture\n                .supplyAsync(() -> cacheRetriever.getCustomer(id));\n        final CompletableFuture<Object> dbFuture = CompletableFuture\n                .supplyAsync(() -> dbRetriever.getCustomer(id));\n\n        return CompletableFuture.anyOf(cacheFuture, dbFuture);\n    }\n}","title":"代码清单3-11"},{"location":"/chapter-03/index.html#代码清单3-12","text":"def getProductInventoryByPostalCode(\n  productSku: Long,\n  postalCode: String): Future[(Long, Map[String, Long])] = {\n  // Import the duration DSL to be used in the timeout\n  import scala.concurrent.duration._\n\n  // Provide the thread pool and Future timeout value to be applied\n  implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(new ForkJoinPool())\n  implicit val timeout: FiniteDuration = 250 milliseconds\n\n  // Define the futures so they can start doing their work\n  val localInventoryFuture = Future {\n    inventoryService.currentInventoryInWarehouse(\n      productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = Future {\n    inventoryService.currentInventoryOverallByWarehouse(\n      productSku)\n  }\n\n  // Retrieve the values and return a future of the combined result\n  for {\n    local ← localInventoryFuture\n    overall ← overallInventoryFutureByWarehouse\n  } yield (local, overall)\n}","title":"代码清单3-12"},{"location":"/chapter-03/index.html#代码清单3-13","text":"import scala.async.Async.{ async, await }\nval resultFuture = async {\n  val localInventoryFuture = async {\n    inventoryService.currentInventoryInWarehouse(productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = async {\n    inventoryService.currentInventoryOverallByWarehouse(productSku)\n  }\n  (await(localInventoryFuture), await(overallInventoryFutureByWarehouse))\n}","title":"代码清单3-13"},{"location":"/chapter-03/index.html#代码清单3-14","text":"package chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n    public void observe(String[] strings) {\n        Observable.fromArray(strings).subscribe((s) -> {\n                System.out.println(\"Received \" + s);\n        });\n    }\n}","title":"代码清单3-14"},{"location":"/chapter-03/index.html#代码清单3-15","text":"package chapter03.rxjava;\n\npublic class RxJavaExampleDriver {\n    private static final RxJavaExample rxJavaExample = new RxJavaExample();\n    public static void main(String[] args) {\n        String[] strings = { \"a\", \"b\", \"c\" };\n        rxJavaExample.observe(strings);\n    }\n}","title":"代码清单3-15"},{"location":"/chapter-03/index.html#代码清单3-16","text":"package chapter03.actor\n\nimport akka.actor._\nimport akka.actor.SupervisorStrategy.Restart\nimport akka.event.LoggingReceive\n\ncase object Start\ncase class CounterMessage(counterValue: Int)\ncase class CounterTooLargeException(message: String) extends Exception(message)\n\nclass SupervisorActor extends Actor with ActorLogging {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: CounterTooLargeException ⇒ Restart\n  }\n\n  private val actor2 = context.actorOf(Props[SecondActor], \"second-actor\")\n  private val actor1 = context.actorOf(Props(new FirstActor(actor2)), \"first-actor\")\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Start ⇒ actor1 ! Start\n  }\n}\n\nclass AbstractCounterActor extends Actor with ActorLogging {\n  protected var counterValue = 0\n\n  def receive: PartialFunction[Any, Unit] = {\n    case _ ⇒\n  }\n\n  def counterReceive: Receive = LoggingReceive {\n    case CounterMessage(i) if i <= 1000 ⇒\n      counterValue = i\n      log.info(s\"Counter value: $counterValue\")\n      sender ! CounterMessage(counterValue + 1)\n    case CounterMessage(_) ⇒\n      throw CounterTooLargeException(\n        \"Exceeded max value of counter!\")\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    context.parent ! Start\n  }\n}\n\nclass FirstActor(secondActor: ActorRef) extends AbstractCounterActor {\n  override def receive = LoggingReceive {\n    case Start ⇒\n      context.become(counterReceive)\n      log.info(\"Starting counter passing.\")\n      secondActor ! CounterMessage(counterValue + 1)\n  }\n}\n\nclass SecondActor() extends AbstractCounterActor {\n  override def receive: Receive = counterReceive\n}\n\nobject Example extends App {\n  val system = ActorSystem(\"counter-supervision-example\")\n  val supervisor = system.actorOf(Props[SupervisorActor])\n  supervisor ! Start\n}","title":"代码清单3-16"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——原则化的失败处理 ·"},{"location":"/chapter-07/index.html#第7章-原则化的失败处理","text":"","title":"第7章——原则化的失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有限定的一致性 ·"},{"location":"/chapter-08/index.html#第8章-有限定的一致性","text":"","title":"第8章——有限定的一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需的不确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需的不确定性","text":"","title":"第9章——按需的不确定性"},{"location":"/chapter-09/index.html#数学函数","text":"f(x) = x + 1\ng(x) = x - 1\nh(x) = f(x) - g(x)","title":"数学函数"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"","title":"第10章——消息流"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-11/index.html#代码清单11-1","text":"Listing 11.1 Testing a purely synchronous translation function\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\ntranslate(input) should be(output)","title":"代码清单11-1"},{"location":"/chapter-11/index.html#代码清单11-2","text":"val input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = translate(input)\n// what now?","title":"代码清单11-2"},{"location":"/chapter-11/index.html#代码清单11-3","text":"val input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\n// when can we continue?","title":"代码清单11-3"},{"location":"/chapter-11/index.html#代码清单11-4","text":"while (!future.isCompleted) Thread.sleep(50)","title":"代码清单11-4"},{"location":"/chapter-11/index.html#代码清单11-5","text":"var i = 20\nwhile (!future.isCompleted && i > 0) {\n  i -= 1\n  Thread.sleep(50)\n}\nif (i == 0) fail(\"translation was not received in time\")","title":"代码清单11-5"},{"location":"/chapter-11/index.html#代码清单11-6","text":"Listing 11.2 Awaiting the result blocks synchronously on the translation\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval result = Await.result(translate(input), 1.second)\nresult should be(output)","title":"代码清单11-6"},{"location":"/chapter-11/index.html#代码清单11-7","text":"Listing 11.3 Expecting replies with a TestProbe\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(1.second, output)","title":"代码清单11-7"},{"location":"/chapter-11/index.html#代码清单11-8","text":"Listing 11.4 Using a TestProbe to receive the response from the scheduler\nval probe = TestProbe()\nval start = Timestamp.now\nscheduler ! Schedule(probe.ref, \"tick\", 1.second)\nprobe.expectMsg(2.seconds, \"tick\")\nval stop = Timestamp.now\nval duration = stop - start\nassert(duration > 950.millis, \"tick came in early\")\nassert(duration < 1050.millis, \"tick came in late\")\n// when can we continue?","title":"代码清单11-8"},{"location":"/chapter-11/index.html#代码清单11-9","text":"Listing 11.5 Determining 95th percentile latency\nval probe = TestProbe()\nval echo = echoService(\"keepSLA\")\nval N = 200\nval timings = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  echo ! Request(string, probe.ref)\n  probe.expectMsg(100.millis, s\"test run $i\", Response(string))\n  val stop = Timestamp.now\n  stop - start\n}\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 1.millisecond\nninetyfifthPercentile.toFiniteDuration should be <= SLA","title":"代码清单11-9"},{"location":"/chapter-11/index.html#代码清单11-10","text":"Listing 11.6 Generating the test samples in parallel with the Ask pattern\nval echo = echoService(\"keepSLAfuture\")\nval N = 10000\nval timingFutures = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  (echo ? (Request(string, _))) collect {\n    case Response(`string`) ⇒ Timestamp.now - start\n  }\n}\nval futureOfTimings = Future.sequence(timingFutures)\nval timings = Await.result(futureOfTimings, 5.seconds)\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 500.milliseconds else 100.milliseconds\nninetyfifthPercentile.toFiniteDuration should be < SLA","title":"代码清单11-10"},{"location":"/chapter-11/index.html#代码清单11-12","text":"Listing 11.8 Verifying that no additional messages are received\nimport scala.concurrent.duration._\nval scheduler = system.actorOf(Scheduler.props)\n\nval probe = TestProbe()\nscheduler ! ScheduleRepeatedly(probe.ref, 1.second, \"tick\")\nval token = probe.expectMsgType[SchedulerToken]\nprobe.expectMsg(1500.millis, \"tick\")\nscheduler ! CancelSchedule(token, probe.ref)\nprobe.expectMsg(100.millis, ScheduleCanceled)\nprobe.expectNoMessage(2.seconds)","title":"代码清单11-12"},{"location":"/chapter-11/index.html#代码清单11-13","text":"Listing 11.9 Matching responses to requests with a correlation ID\nval ingestService = system.actorOf(DataIngester.props)\nval probe = TestProbe()\ningestService ! Retrieve(url, \"myID\", probe.ref)\nval replies = probe.receiveWhile(1.second) {\n  case r @ Record(\"myID\", _) ⇒ r\n}\nprobe.expectMsg(0.seconds, EOF)","title":"代码清单11-13"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"","title":"第12章——容错及恢复模式"},{"location":"/chapter-12/index.html#代码清单12-1","text":"Listing 12.1 Using a circuit breaker to give a failed component time to recover\nprivate object StorageFailed extends RuntimeException\n\nprivate def sendToStorage(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  val f: Future[StorageStatus] = ???\n  f.map {\n    case StorageStatus.Failed => throw StorageFailed\n    case other => other\n  }\n}\n\nimport scala.concurrent.duration._\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  5,\n  300.millis,\n  30.seconds,\n)\n\ndef persist(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(sendToStorage(job))\n    .recover {\n      case StorageFailed => StorageStatus.Failed\n      case _: TimeoutException => StorageStatus.Unknown\n      case _: CircuitBreakerOpenException => StorageStatus.Failed\n    }\n}","title":"代码清单12-1"},{"location":"/chapter-12/index.html#代码清单12-2","text":"Listing 12.2 Protecting a component by using a rate limiter\nimport scala.concurrent.Future\nimport scala.concurrent.duration.{ Deadline, FiniteDuration }\n\ncase object RateLimitExceeded extends RuntimeException\n\nclass RateLimiter(requests: Int, period: FiniteDuration) {\n  private val startTimes = {\n    val onePeriodAgo = Deadline.now - period\n    Array.fill(requests)(onePeriodAgo)\n  }\n  private var position = 0\n  private def lastTime = startTimes(position)\n  private def enqueue(time: Deadline): Unit = {\n    startTimes(position) = time\n    position += 1\n    if (position == requests) position = 0\n  }\n  def call[T](block: ⇒ Future[T]): Future[T] = {\n    val now = Deadline.now\n    if ((now - lastTime) < period) {\n      Future.failed(RateLimitExceeded)\n    } else {\n      enqueue(now)\n      block\n    }\n  }\n}","title":"代码清单12-2"},{"location":"/chapter-12/index.html#代码清单12-3","text":"Listing 12.3 Protecting a component by using a rate limiter\nprivate val limiter = new RateLimiter(100, 2.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  limiter\n    .call(persist(job))\n    .recover {\n      case RateLimitExceeded ⇒ StorageStatus.Failed\n    }\n}","title":"代码清单12-3"},{"location":"/chapter-12/index.html#代码清单12-4","text":"Listing 12.4 Gating a client\nprivate val limiter = new RateLimiter(100, 2.seconds)\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  10, Duration.Zero, 10.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(limiter.call(persist(job)))\n    .recover {\n      case RateLimitExceeded              ⇒ StorageStatus.Failed\n      case _: CircuitBreakerOpenException ⇒ StorageStatus.Gated\n    }\n}","title":"代码清单12-4"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"","title":"第14章——资源管理模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"","title":"第15章——消息流模式"},{"location":"/chapter-15/index.html#代码清单15-1","text":"Listing 15.1 Server responding to the address that originated the request\npublic class Server {\n    static final int SERVER_PORT = 8888;\n\n    static public void main(String[] args) throws IOException {\n        // bind a socket for receiving packets\n        try (final DatagramSocket socket =\n                     new DatagramSocket(SERVER_PORT)) {\n\n            // receive one packet\n            final byte[] buffer = new byte[1500];\n            final DatagramPacket packet1 =\n                    new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet1);\n\n            final SocketAddress sender = packet1.getSocketAddress();\n            System.out.println(\"server: received \" +\n                    new String(packet1.getData()));\n            System.out.println(\"server: sender was \" + sender);\n\n            // send response back\n            final byte[] response = \"got it!\".getBytes();\n            final DatagramPacket packet2 =\n                    new DatagramPacket(response, response.length, sender);\n            socket.send(packet2);\n        }\n    }\n}","title":"代码清单15-1"},{"location":"/chapter-15/index.html#代码清单15-2","text":"Listing 15.2 Client sending a request and then blocking until the server responds\npublic class Client {\n    static public void main(String[] args) throws IOException {\n        // get local socket with random port\n        try (final DatagramSocket socket = new DatagramSocket()) {\n\n            // send message to server\n            final byte[] request = \"hello\".getBytes();\n            final SocketAddress serverAddress =\n                    new InetSocketAddress(\"localhost\", SERVER_PORT);\n            final DatagramPacket packet1 =\n                    new DatagramPacket(request, request.length, serverAddress);\n            socket.send(packet1);\n\n            // receive one packet\n            final byte[] buffer = new byte[1500];\n            final DatagramPacket packet2 =\n                    new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet2);\n\n            final SocketAddress sender = packet2.getSocketAddress();\n            System.out.println(\"client: received \" +\n                    new String(packet2.getData()));\n            System.out.println(\"client: sender was \" + sender);\n        }\n    }\n}\nServer 的输出结果\nserver: received hello\nserver: sender was /127.0.0.1:55589\nClient 的可能输出结果\nclient: received got it!\nclient: sender was /127.0.0.1:8888\nHTTP Request Header\nGET /request?msg=hello HTTP/1.1\nHost: client-interface.our.application.domain\nAccept: application/json\nHTTP Response Header\nHTTP/1.1 200 OK\n...\nContent-Type: application/json\nContent-Length: 22\n{\"response\":\"got it!\"}","title":"代码清单15-2"},{"location":"/chapter-15/index.html#代码清单15-3","text":"Listing 15.3 Untyped Akka Actors modeling request–response\nobject RequestResponseActors {\n\n  case class Request(msg: String)\n  case class Response(msg: String)\n\n  class Responder extends Actor {\n    def receive: Receive = {\n      case Request(msg) ⇒\n        println(s\"got request: $msg\")\n        sender() ! Response(\"got it!\")\n    }\n  }\n\n  class Requester(responder: ActorRef) extends Actor {\n    responder ! Request(\"hello\")\n\n    def receive: Receive = {\n      case Response(msg) ⇒\n        println(s\"got response: $msg\")\n        context.system.terminate()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sys = ActorSystem(\"ReqRes\")\n    val responder = sys.actorOf(Props[Responder], \"responder\")\n    val requester = sys.actorOf(Props(new Requester(responder)), \"requester\")\n  }\n\n}\n运行结果\ngot request: hello\ngot response: got it!","title":"代码清单15-3"},{"location":"/chapter-15/index.html#代码清单15-4","text":"Listing 15.4 Including the response explicitly in the request message\nobject RequestResponseTypedActors {\n\n  case class Request(msg: String, replyTo: ActorRef[Response])\n  case class Response(msg: String)\n\n  val responder: Behavior[Request] =\n    Static {\n      case Request(msg, replyTo) ⇒\n        println(s\"got request: $msg\")\n        replyTo ! Response(\"got it!\")\n    }\n\n  def requester(responder: ActorRef[Request]): Behavior[Response] =\n    SelfAware { self ⇒\n      responder ! Request(\"hello\", self)\n      Total {\n        case Response(msg) ⇒\n          println(s\"got response: $msg\")\n          Stopped\n      }\n    }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(\"ReqResTyped\", ContextAware[Unit] { ctx ⇒\n      val res = ctx.spawn(responder, \"responder\")\n      val req = ctx.watch(ctx.spawn(requester(res), \"requester\"))\n      Full {\n        case Sig(_, Terminated(`req`)) ⇒ Stopped\n      }\n    })\n  }\n}","title":"代码清单15-4"},{"location":"/chapter-15/index.html#代码清单15-5","text":"Listing 15.5 Request–response based on a one-way messaging protocol\nvar amqp = require('amqplib/callback_api');\namqp.connect('amqp://localhost', function(err, conn) {\n    conn.createChannel(function(err, ch) {\n        var q = 'rpc_queue';\n        ch.assertQueue(q, {durable: false});\n        ch.prefetch(1);\n        ch.consume(q, function reply(msg) {\n            console.log(\"got request: %s\", msg.content.toString());\n            ch.sendToQueue(msg.properties.replyTo,\n                new Buffer('got it!'),\n                {correlationId: msg.properties.correlationId});\n            ch.ack(msg);\n        });\n    });\n});","title":"代码清单15-5"},{"location":"/chapter-15/index.html#代码清单15-6","text":"Listing 15.6 Listening for a response with the same correlation ID as the original request\nvar uuid = require('node-uuid');\namqp.connect('amqp://localhost', function(err, conn) {\n    conn.createChannel(function(err, ch) {\n        ch.assertQueue('responses', {}, function(err, q) {\n            var corr = uuid.v1();\n            ch.consume(q.queue, function(msg) {\n                if (msg.properties.correlationId === corr) {\n                    console.log('got response: %s', msg.content.toString());\n                    setTimeout(function() { conn.close(); process.exit(0) }, 500);\n                }\n            }, {noAck: true});\n            ch.sendToQueue('rpc_queue',\n                new Buffer('hello'),\n                { correlationId: corr, replyTo: q.queue });\n        });\n    });\n});","title":"代码清单15-6"},{"location":"/chapter-15/index.html#smtp","text":"S: 220 mailhost.example.com ESMTP Postfix\nC: HELO alice-workstation.example.com\nS: 250 Hello alice-workstation.example.com\nC: MAIL FROM:<alice@example.com>\nS: 250 Ok\nC: RCPT TO:<bob@example.com>\nS: 250 Ok\nC: DATA\nS: 354 End data with <CR><LF>.<CR><LF>\nC: From: \"Alice\" <alice@example.com>\nC: To: \"Bob\" <bob@example.com>\nC: Date: Fri, 23 October 2015 10:34:12 +0200\nC: Subject: lunch\nC:\nC: Hi Bob,\nC:\nC: sorry, I cannot make it, something else came up.\nC:\nC: Regards, Alice\nC: .\nS: 250 Ok, queued as 4567876345\nC: QUIT\nS: 221 Bye","title":"SMTP"},{"location":"/chapter-15/index.html#代码清单15-7","text":"Listing 15.7 Encapsulated information needed for multiple SMTP exchanges\ncase class SendEmail(\n  sender:     String,\n  recipients: List[String],\n  body:       String, correlationID: UUID,\n  replyTo: ActorRef[SendEmailResult])\ncase class SendEmailResult(\n  correlationID: UUID,\n  status:        StatusCode,\n  explanation:   Option[String]) extends Result","title":"代码清单15-7"},{"location":"/chapter-15/index.html#代码清单15-8","text":"Listing 15.8 Separating the body so it can be delivered on demand\ncase class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])(body: Source[String]) extends StreamedRequest {\n  override def payload: Source[String] = body\n}","title":"代码清单15-8"},{"location":"/chapter-15/index.html#代码清单15-9","text":"Listing 15.9 Enabling the body to be pulled by the recipient\ncase class SendEmail(sender: String, recipients: List[String],\n                     bodyLocation:  URL,\n                     correlationID: UUID,\n                     replyTo:       ActorRef[SendEmailResult])","title":"代码清单15-9"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"","title":"第16章——流控制模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"","title":"第17章——状态管理和持久化模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"}]}