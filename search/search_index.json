{"docs":[{"location":"/index.html","text":"目录 内容提要 第一部分 简介 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业工具 第二部分 微言大义 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——有规划的失败处理 第8章——有界一致性 第9章——按需的不确定性 第三部分 设计模式 第10章——消息流 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言 额外指引 勘误\n《反应式设计模式》\n原书名《Reactive Design Patterns》\n一本有关反应式（Reactive）系统设计的模式书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/abstract.html","text":"","title":"内容提要 ·"},{"location":"/abstract.html#内容提要","text":"TODO","title":"内容提要"},{"location":"/part1.html","text":"","title":"第一部分 简介 ·"},{"location":"/part1.html#第一部分-简介","text":"你有曾思考过高性能Web应用程序是如何实现的吗？社交网络和大型零售网站肯定有一些秘密配方使得系统运行迅速并且可靠，但这些秘密是什么呢？在这本书中，我们将为你揭晓谜底，你将学习到这些近似永远不出故障，并且能够满足数十亿人需要的系统背后的设计原则与模式。虽然你所构建的系统未必有如此雄心壮志的要求，但是它们主要的特质应该是一致的：\n你想要你的应用程序可靠地工作，即使某些部件（硬件或者软件）有可能出现故障。\n你希望你的应用程序在你需要支撑更多的用户时，可以持续地提供服务，而且你希望能够通过添加或者删除资源来调整它的能力，从而适应不断变化的需求（没有可以预测未来的水晶球的帮助，很难进行正确的容量规划）。\n在第1章中，我们将勾勒出一个具备这些特质的应用程序的开发过程。我们将指明你会遇到的挑战，并基于一个具体的例子（一个假想中的Gmail服务实现）给出解决方案，但是我们将会以不提供具体的技术选型的形式进行。\n这个使用场景为接下来在第2章中对《反应式宣言》所进行的详细讨论作了铺垫。该宣言以简洁、抽象的形式撰写，目的是为了聚焦于它的本质：将多个独立的、有效的程序特性凝聚为一个整体，从而形成更大的合力。我们将通过把高度抽象的特质分解为更小的部分，并解释各部分又是如何合回一体的过程，来展现这一点。\n我们将会以第3章结束这一部分，其大致地介绍了行业工具：函数式编程、Future 和 Promise、通信顺序进程（CSP）、 Observer 和 Observable（Reactive Extensions）以及 Actor 模型。","title":"第一部分 简介"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"我们的初心，是构建一个对用户即时响应的（responsive）系统。这意味着该系统无论在什么样的情况下，都应该能即时响应用户的输入。由于任何单台计算机在任何时刻都有可能宕机，所以我们需要将这一个系统分布到多台计算机上。引入分布式结构这个额外的基础需求使我们意识到：构建这样的系统需要新的架构模式（或者重新发现旧模式）。在过去，我们建立了各种方法来允许我们维持某种假像：单线程的本地运算能够魔法般地扩展运行在多个处理器核心或者网络节点上。然而，这虚实之间的沟壑已经大到难以为继。而解决之法是让我们的应用程序中所具有的分布和并发的本质明明白白地反映到编程模型上来，并使它变成我们的优势。\n没有代码清单","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"这一章详细地介绍了《反应式宣言》：原文文字简练且内容紧凑，我们将在这里加以展开并进行深入地讨论。有关该宣言相关理论的更多背景知识，请参阅本书第二部分。","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#2-1-对用户作出反应","text":"代码清单 2-1 图片服务中简单 Controller 的一段代码\npublic interface Images {\n  Image get(String Key);\n\n  void add(String key, Image image);\n}\n\npublic Images cache;\npublic Images database;\n\npublic Image retrieveImages(String key) {\n  Image result = cache.get(key);\n  if (result != null) {\n    return result;\n  } else {\n    result = database.get(key);\n    if (result != null) {\n      cache.add(key, result);\n      return result;\n    } else {\n      return fallback;\n    }\n  }\n}","title":"2.1 对用户作出反应"},{"location":"/chapter-02/index.html#2-2-利用并行性","text":"SimpleFunction.scala\nval result = f(42)\nSequentialExecution.java\nReplyA a = computeA();\nReplyB b = computeB();\nReplyC c = computeC();\n\nResult r = aggregate(a, b, c);\nParallelExecutionWithJavaFuture.java\nFuture<ReplyA> a = taskA();\nFuture<ReplyB> b = taskB();\nFuture<ReplyC> c = taskC();\n\nResult r = aggregate(a.get(), b.get(), c.get());\nParallelExecutionWithScalaFuture.scala\nval fa: Future[ReplyA] = taskA()\nval fb: Future[ReplyB] = taskB()\nval fc: Future[ReplyC] = taskC()\n\nval fr: Future[Result] = for (a ← fa; b ← fb; c ← fc)\n  yield aggregate(a, b, c)\nBlockingSocketRead.java\nfinal Socket socket = new Socket(\"127.0.0.1\", 8080);\nsocket.getOutputStream().write(requestMessageBytes);\nfinal int bytesRead = socket.getInputStream().read(responseBuffer);\nAskActorWithJava8.java\nCompletionStage<Response> future =\n        ask(actorRef, request, timeout)\n                .thenApply(Response.class::cast);\nfuture.thenAccept(response -> AskActorWithJava8.processIt(response));","title":"2.2 利用并行性"},{"location":"/chapter-02/index.html#2-4-对失败作出反应","text":"ExceptionHandler.scala\ntry {\n  f(i)\n} catch {\n  case _: java.lang.ArithmeticException ⇒ Int.MaxValue\n  case ex: java.lang.StackOverflowError ⇒ ???\n  case ex: java.net.ConnectException    ⇒ ???\n}","title":"2.4 对失败作出反应"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业工具 ·"},{"location":"/chapter-03/index.html#第3章-行业工具","text":"","title":"第3章——行业工具"},{"location":"/chapter-03/index.html#3-2-函数式编程","text":"代码清单3-1 不安全的、可变的消息类，可能会隐含非预期的行为\nimport java.util.Date;\n\npublic class Unsafe {\n  private Date timestamp;\n  private final StringBuffer message;\n\n  public Unsafe(Date timestamp, StringBuffer message) {\n    this.timestamp = timestamp;\n    this.message = message;\n  }\n\n  public synchronized Date getTimestamp() {\n    return timestamp;\n  }\n\n  public synchronized void setTimestamp(Date timestamp) {\n    this.timestamp = timestamp;\n  }\n\n  public StringBuffer getMessage() {\n    return message;\n  }\n}\n代码清单 3-2 不可变的消息类，其行为是可预知的，并易于推断\nimport java.util.Date;\n\npublic class Immutable {\n  private final Date timestamp;\n  private final String message;\n\n  public Immutable(final Date timestamp, final String message) {\n    this.timestamp = new Date(timestamp.getTime());\n    this.message = message;\n  }\n\n  public Date getTimestamp() {\n    return new Date(timestamp.getTime());\n  }\n\n  public String getMessage() {\n    return message;\n  }\n}\nMessage.scala\nimport java.util.Date\n\ncase class Message(timestamp: Date, message: String)\nUsingStringBuffer.java\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\n    \"original '%s', new value '%s'\",\n    original,\n    reversed));\n代码清单 3-3 引用透明性：允许代换预先计算好的值\npublic class Rooter {\n  private final double value;\n  private Double root = null;\n\n  public Rooter(double value) {\n    this.value = value;\n  }\n\n  public double getValue() {\n    return value;\n  }\n\n  public double getRoot() {\n    if (root == null) {\n      root = Math.sqrt(value);\n    }\n    return root;\n  }\n}\n代码清单3-4 因副作用而受限的可用性\npublic class SideEffecting implements Serializable, Cloneable {\n  private int count;\n\n  public SideEffecting(int start) {\n    this.count = start;\n  }\n\n  public int next() {\n    this.count += Math.incrementExact(this.count);\n    return this.count;\n  }\n}\nIntSeeding.java\nfinal int next = se.next();\nif (logger.isDebugEnabled()) {\n  logger.debug(\"Next is \" + se.next());\n}\nreturn next;\nUsingMapFunction.java\nfinal List<Integer> numbers = Arrays.asList(1, 2, 3);\nfinal List<Integer> numbersPlusOne =\n        numbers.stream()\n                .map(number -> number + 1)\n                .collect(Collectors.toList());\nPython REPL\n>>> def addOne(x):\n... returnx+1\n...\n>>> myFunction = addOne\n>>> myFunction(3)\n4","title":"3.2 函数式编程"},{"location":"/chapter-03/index.html#3-4-对反应式设计的现有支持","text":"sample.js\nvar http = require('http');\n\nvar counter = 0;\n\nhttp.createServer(function (req, res) {\n  counter++;\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Sending response: ' + counter + ' via callback!\\n');\n}).listen(8888, '127.0.0.1');\n\nconsole.log('Server up on 127.0.0.1:8888, send requests!');\nsample.go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\titerations := 10\n    myChannel := make(chan int)\n\n    go producer(myChannel, iterations)\n    go consumer(myChannel, iterations)\n\n    time.Sleep(500 * time.Millisecond)\n}\n\nfunc producer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        fmt.Println(\"Sending: \", i)\n        myChannel <- i\n    }   \n}\n\nfunc consumer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        recVal := <-myChannel\n        fmt.Println(\"Received: \", recVal)\n    }   \n}\n代码清单3-5 从更快的数据源获取结果\npublic class ParallelRetrievalExample {\n  private final CacheRetriever cacheRetriever;\n  private final DBRetriever dbRetriever;\n\n  ParallelRetrievalExample(CacheRetriever cacheRetriever,\n      DBRetriever dbRetriever) {\n    this.cacheRetriever = cacheRetriever;\n    this.dbRetriever = dbRetriever;\n  }\n\n  public Object retrieveCustomer(final long id) {\n        final CompletableFuture<Object> cacheFuture = CompletableFuture\n                .supplyAsync(() -> cacheRetriever.getCustomer(id));\n        final CompletableFuture<Object> dbFuture = CompletableFuture\n                .supplyAsync(() -> dbRetriever.getCustomer(id));\n\n        return CompletableFuture.anyOf(cacheFuture, dbFuture);\n    }\n}\n代码清单3-6 使用Scala编程语言将两个Future的结果组合为单一结果\ndef getProductInventoryByPostalCode(\n  productSku: Long,\n  postalCode: String): Future[(Long, Map[String, Long])] = {\n  // Import the duration DSL to be used in the timeout\n  import scala.concurrent.duration._\n\n  // Provide the thread pool and Future timeout value to be applied\n  implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(new ForkJoinPool())\n  implicit val timeout: FiniteDuration = 250 milliseconds\n\n  // Define the futures so they can start doing their work\n  val localInventoryFuture = Future {\n    inventoryService.currentInventoryInWarehouse(\n      productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = Future {\n    inventoryService.currentInventoryOverallByWarehouse(\n      productSku)\n  }\n\n  // Retrieve the values and return a future of the combined result\n  for {\n    local ← localInventoryFuture\n    overall ← overallInventoryFutureByWarehouse\n  } yield (local, overall)\n}\nStagedFuturesAsyncExample.scala\nimport scala.async.Async.{ async, await }\nval resultFuture = async {\n  val localInventoryFuture = async {\n    inventoryService.currentInventoryInWarehouse(productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = async {\n    inventoryService.currentInventoryOverallByWarehouse(productSku)\n  }\n  (await(localInventoryFuture), await(overallInventoryFutureByWarehouse))\n}\nRxJavaExample.java\npackage chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n  public void observe(String[] strings) {\n        Observable.fromArray(strings).subscribe((s) -> {\n                System.out.println(\"Received \" + s);\n        });\n    }\n}\nRxJavaExampleDriver.java\npackage chapter03.rxjava;\n\npublic class RxJavaExampleDriver {\n  private static final RxJavaExample rxJavaExample = new RxJavaExample();\n\n  public static void main(String[] args) {\n    String[] strings = {\"a\", \"b\", \"c\"};\n    rxJavaExample.observe(strings);\n  }\n}\n代码清单3-7 一个使用 Akka 的Actor的例子\npackage chapter03.actor\n\nimport akka.actor._\nimport akka.actor.SupervisorStrategy.Restart\nimport akka.event.LoggingReceive\n\ncase object Start\ncase class CounterMessage(counterValue: Int)\ncase class CounterTooLargeException(message: String) extends Exception(message)\n\nclass SupervisorActor extends Actor with ActorLogging {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: CounterTooLargeException ⇒ Restart\n  }\n\n  private val actor2 = context.actorOf(Props[SecondActor], \"second-actor\")\n  private val actor1 = context.actorOf(Props(new FirstActor(actor2)), \"first-actor\")\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Start ⇒ actor1 ! Start\n  }\n}\n\nclass AbstractCounterActor extends Actor with ActorLogging {\n  protected var counterValue = 0\n\n  def receive: PartialFunction[Any, Unit] = {\n    case _ ⇒\n  }\n\n  def counterReceive: Receive = LoggingReceive {\n    case CounterMessage(i) if i <= 1000 ⇒\n      counterValue = i\n      log.info(s\"Counter value: $counterValue\")\n      sender ! CounterMessage(counterValue + 1)\n    case CounterMessage(_) ⇒\n      throw CounterTooLargeException(\n        \"Exceeded max value of counter!\")\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    context.parent ! Start\n  }\n}\n\nclass FirstActor(secondActor: ActorRef) extends AbstractCounterActor {\n  override def receive = LoggingReceive {\n    case Start ⇒\n      context.become(counterReceive)\n      log.info(\"Starting counter passing.\")\n      secondActor ! CounterMessage(counterValue + 1)\n  }\n}\n\nclass SecondActor() extends AbstractCounterActor {\n  override def receive: Receive = counterReceive\n}\n\nobject Example extends App {\n  val system = ActorSystem(\"counter-supervision-example\")\n  val supervisor = system.actorOf(Props[SupervisorActor])\n  supervisor ! Start\n}","title":"3.4 对反应式设计的现有支持"},{"location":"/part2.html","text":"","title":"第二部分 微言大义 ·"},{"location":"/part2.html#第二部分-微言大义","text":"这本书的第一部分综述了反应式系统的价值。你看到了对用户输入总是保持回弹性和可伸缩性的需要，从而即使在失败和不同负载的情况下也能保持即时响应性。在我们探索这些可取的属性过程中，你得出了需要使用消息驱动来作为底层实现的必要性。\n第二部分对反应式的 4 个特质进行了补充说明：提出了一组构建反应式架构的构建块。这一部分的重点是如何做到反应式，而第一部分则描述了我们要实现的目标及缘由。在这一部分所讨论的指导原则，以及我们在第3章中所介绍的行业工具，一起构成了第三部分中多种模式的基础。\n我们决定以一种连贯、凝聚的方式组织这些材料，以便你在构建反应式应用程序的过程中，推敲你自己的模式设计时，本书可以方便地作为一个紧凑的参考。作为一个完整的反应式架构的360度全景，这一部分涵盖了大量的基础理论。你可能想要先阅读第4章，然后略读这一部分的其余章节，并在你研究这本书第三部分中所介绍的相应模式时，再回过头来细细研读这部分中的对应章节。\n在这一部分中，你将学习到：\n通过显式的异步消息传递来使得封装和隔离成为可能； 通过位置透明性，提高组合能力，并添加水平扩展能力； 应用分而治之（divide et regna），以层级化模块的形式组织系统； 这个层级结构如何使得原则化的失败处理成为可能； 在分布式系统中实现足够一致的程序语义； 尽可能地避免不确定性，并在必要时添加； 使用基于消息流的拓扑指导反应式应用程序设计。","title":"第二部分 微言大义"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"事件，是建立消息传递的基石：事实上，一个特定条件的触发（事件本身）捆绑了上下文信息——如某人在某时某地做了某事——并且被生产者以消息的形式传送。而感兴趣的各方则可以通过一个共同的传输机制得知并消费该消息。\n没有代码清单","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"前面的章节介绍了消息传递作为解耦协作对象的一种方式。将通信变为异步、非阻塞的，而不是调用同步方法，这使得接收者能够在不同的执行上下文（比如不同的线程）中执行其工作。但为什么要止步于一台机器内的交互呢？消息传递在本地和远程交互中的工作原理相同。调度一个任务在本地机器上稍后运行，与发送一个网络包到不同的主机并在那里触发执行，并没有本质的区别。在这一章中，我们将探讨这个视角所提供的可能性，以及它对诸如延迟、吞吐量和消息丢失的概率等性能量化指标的影响。\n没有代码清单","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"上一章假定程序通常由多个组件构成，这些组件以某种方式分离：由不同的团队开发不同的功能领域；通过接口访问模块；模块被打包成容易被替换的方式；等等。在过去的几十年间，我们花费了大量的精力在编程语言中定义模块的语法和语义上，以及用于部署他们的库和基础设施。重要的问题是，我们应该如何划分一个问题，从而成功地解决它呢？\n本章无代码清单","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——有规划的失败处理 ·"},{"location":"/chapter-07/index.html#第7章-有规划的失败处理","text":"你已经知道回弹性要求对系统进行分布和划分。分布式是唯一可以避免因单点故障（无论是硬件、软件或者人为失误）而导致全局失败的方式；划分可以隔离不同的分布式单元，使得任意单元的失败都不会扩散到其他单元上。总而言之，为了在失败之后恢复正常的功能，你需要将对失败作出反应的职责委托给一个监督者（supervisor）。\n没有代码清单","title":"第7章——有规划的失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有界一致性 ·"},{"location":"/chapter-08/index.html#第8章-有界一致性","text":"分布式系统（distributed system）的某种定义是：一个各部分允许独立失败的系统。 反应式设计的本质是分布式的：你想对相互隔离的组件进行建模，并且只通过位置透明的消息传递进行交互，从而建立具有回弹性的监督层级结构。这意味着，最终产生的应用程序结构也将要面对分布式所带来的各种后果。在无状态系统中，这类后果主要与失败处理有关，恢复处理手段则如前一章所述。但是当系统需要维护状态时，就没有那么简单了。即使系统的每个部分都完美地工作，时间也是一个（可能导致失败的）因素。正如你在第 2 章中所学习到的，分布式会导致的其中一个后果就是无法保证强一致性（strong consistency）。在这一章中，你将学到有界一致性（delimited consistency），这是退而求其次的最优选。\n没有代码清单","title":"第8章——有界一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需的不确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需的不确定性","text":"这一章为全书最抽象的部分，对于初步理解后面章节来说，这一章的内容并非必需。你可以先直接跳到第10章看看，只要你保证之后还会回来。","title":"第9章——按需的不确定性"},{"location":"/chapter-09/index.html#9-2-函数式反应式编程","text":"f(x) = x + 1\ng(x) = x - 1\nh(x) = f(x) - g(x)","title":"9.2 函数式反应式编程"},{"location":"/part3.html","text":"","title":"第三部分 设计模式 ·"},{"location":"/part3.html#第三部分-设计模式","text":"到目前为止，我们在讨论什么是反应式，以及为什么要应用反应式上已经花费了不少时间。现在是时候关注如何应用反应式了。 在第三部分中，我们将介绍一些可以帮助你实现反应式应用程序的设计模式。我们将首先讨论如何进行测试，以确保你的应用程序是反应式的，这样你就可以有信心接下来的的应用构建是都满足反应式契约的：无论从最小的功能组件，还是到整个跨数据中心部署结构。 然后，我们将深入探讨一些在反应式概念的各个维度上构建反应式系统的特定模式。\n在这一部分中，你将学习到以下内容：\n测试反应式系统，并特别强调异步测试 将内部和外部容错应用到你的应用程序中 管理反应式应用程序的资源 管理应用程序内部及应用程序之间的消息和数据流通 管理反应式系统的状态，以及持久化数据的过程\n对于每一个模式，我们将先以一个简短的段落介绍它的本质（以便回顾时作参考），接着介绍模式会出现在系统中的场景，并给出一个将模式应用到具体问题的详细示例。然后总结出每个模式所能解决的问题、典型特征和适用范围。\n第二部分讨论了搭建反应式系统的基础构建块，在你阅读后续章节时，值得经常回顾第二部分中的相关背景——以我们的经验，通常对一个主题进行二次攻关才会带来灵光乍现的瞬间","title":"第三部分 设计模式"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"","title":"第10章——消息流"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-11/index.html#代码清单11-1","text":"Listing 11.1 Testing a purely synchronous translation function\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\ntranslate(input) should be(output)","title":"代码清单11-1"},{"location":"/chapter-11/index.html#代码清单11-2","text":"val input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = translate(input)\n// what now?","title":"代码清单11-2"},{"location":"/chapter-11/index.html#代码清单11-3","text":"val input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\n// when can we continue?","title":"代码清单11-3"},{"location":"/chapter-11/index.html#代码清单11-4","text":"while (!future.isCompleted) Thread.sleep(50)","title":"代码清单11-4"},{"location":"/chapter-11/index.html#代码清单11-5","text":"var i = 20\nwhile (!future.isCompleted && i > 0) {\n  i -= 1\n  Thread.sleep(50)\n}\nif (i == 0) fail(\"translation was not received in time\")","title":"代码清单11-5"},{"location":"/chapter-11/index.html#代码清单11-6","text":"Listing 11.2 Awaiting the result blocks synchronously on the translation\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval result = Await.result(translate(input), 1.second)\nresult should be(output)","title":"代码清单11-6"},{"location":"/chapter-11/index.html#代码清单11-7","text":"Listing 11.3 Expecting replies with a TestProbe\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(1.second, output)","title":"代码清单11-7"},{"location":"/chapter-11/index.html#代码清单11-8","text":"Listing 11.4 Using a TestProbe to receive the response from the scheduler\nval probe = TestProbe()\nval start = Timestamp.now\nscheduler ! Schedule(probe.ref, \"tick\", 1.second)\nprobe.expectMsg(2.seconds, \"tick\")\nval stop = Timestamp.now\nval duration = stop - start\nassert(duration > 950.millis, \"tick came in early\")\nassert(duration < 1050.millis, \"tick came in late\")\n// when can we continue?","title":"代码清单11-8"},{"location":"/chapter-11/index.html#代码清单11-9","text":"Listing 11.5 Determining 95th percentile latency\nval probe = TestProbe()\nval echo = echoService(\"keepSLA\")\nval N = 200\nval timings = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  echo ! Request(string, probe.ref)\n  probe.expectMsg(100.millis, s\"test run $i\", Response(string))\n  val stop = Timestamp.now\n  stop - start\n}\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 1.millisecond\nninetyfifthPercentile.toFiniteDuration should be <= SLA","title":"代码清单11-9"},{"location":"/chapter-11/index.html#代码清单11-10","text":"Listing 11.6 Generating the test samples in parallel with the Ask pattern\nval echo = echoService(\"keepSLAfuture\")\nval N = 10000\nval timingFutures = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  (echo ? (Request(string, _))) collect {\n    case Response(`string`) ⇒ Timestamp.now - start\n  }\n}\nval futureOfTimings = Future.sequence(timingFutures)\nval timings = Await.result(futureOfTimings, 5.seconds)\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 500.milliseconds else 100.milliseconds\nninetyfifthPercentile.toFiniteDuration should be < SLA","title":"代码清单11-10"},{"location":"/chapter-11/index.html#代码清单11-12","text":"Listing 11.8 Verifying that no additional messages are received\nimport scala.concurrent.duration._\nval scheduler = system.actorOf(Scheduler.props)\n\nval probe = TestProbe()\nscheduler ! ScheduleRepeatedly(probe.ref, 1.second, \"tick\")\nval token = probe.expectMsgType[SchedulerToken]\nprobe.expectMsg(1500.millis, \"tick\")\nscheduler ! CancelSchedule(token, probe.ref)\nprobe.expectMsg(100.millis, ScheduleCanceled)\nprobe.expectNoMessage(2.seconds)","title":"代码清单11-12"},{"location":"/chapter-11/index.html#代码清单11-13","text":"Listing 11.9 Matching responses to requests with a correlation ID\nval ingestService = system.actorOf(DataIngester.props)\nval probe = TestProbe()\ningestService ! Retrieve(url, \"myID\", probe.ref)\nval replies = probe.receiveWhile(1.second) {\n  case r @ Record(\"myID\", _) ⇒ r\n}\nprobe.expectMsg(0.seconds, EOF)","title":"代码清单11-13"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"在这一章中，你将学习到在设计应用程序时如何应对失败出现的可能性。我们将通过具体地构建一个具有回弹性的计算引擎来演示几个相应的模式，这个系统允许提交批处理作业，并在有着弹性调度的硬件资源上执行。我们将基于你在第6章和第7章所学习到的知识进行展开，因此，你可能想要回顾一下之前的内容。","title":"第12章——容错及恢复模式"},{"location":"/chapter-12/index.html#12-4-断路器模式","text":"代码清单 12-1 利用断路器使得失败组件有时间恢复\nprivate object StorageFailed extends RuntimeException\n\nprivate def sendToStorage(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  val f: Future[StorageStatus] = ???\n  f.map {\n    case StorageStatus.Failed => throw StorageFailed\n    case other => other\n  }\n}\n\nimport scala.concurrent.duration._\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  5,\n  300.millis,\n  30.seconds,\n)\n\ndef persist(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(sendToStorage(job))\n    .recover {\n      case StorageFailed => StorageStatus.Failed\n      case _: TimeoutException => StorageStatus.Unknown\n      case _: CircuitBreakerOpenException => StorageStatus.Failed\n    }\n}\n代码清单12-2 使用速率限制器保护组件\nimport scala.concurrent.Future\nimport scala.concurrent.duration.{ Deadline, FiniteDuration }\n\ncase object RateLimitExceeded extends RuntimeException\n\nclass RateLimiter(requests: Int, period: FiniteDuration) {\n  private val startTimes = {\n    val onePeriodAgo = Deadline.now - period\n    Array.fill(requests)(onePeriodAgo)\n  }\n  private var position = 0\n  private def lastTime = startTimes(position)\n  private def enqueue(time: Deadline): Unit = {\n    startTimes(position) = time\n    position += 1\n    if (position == requests) position = 0\n  }\n  def call[T](block: ⇒ Future[T]): Future[T] = {\n    val now = Deadline.now\n    if ((now - lastTime) < period) {\n      Future.failed(RateLimitExceeded)\n    } else {\n      enqueue(now)\n      block\n    }\n  }\n}\n代码清单12-3 断路器：限制来自同一个客户端的请求\nprivate val limiter = new RateLimiter(100, 2.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  limiter\n    .call(persist(job))\n    .recover {\n      case RateLimitExceeded ⇒ StorageStatus.Failed\n    }\n}\n代码清单12-4 门控一个客户端\nprivate val limiter = new RateLimiter(100, 2.seconds)\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  10, Duration.Zero, 10.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(limiter.call(persist(job)))\n    .recover {\n      case RateLimitExceeded              ⇒ StorageStatus.Failed\n      case _: CircuitBreakerOpenException ⇒ StorageStatus.Gated\n    }\n}","title":"12.4. 断路器模式"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"","title":"第14章——资源管理模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"在这一章中，我们将探讨一些存在于反应式组件之间最基本的通信模式：具体而言，我们将讨论消息是如何在它们之间流动的。在第10章中，我们讨论了理论背景，提到了系统中的通信路径设计对于系统的成功来说至关重要——无论是对现实世界的组织，还是反应式应用程序。","title":"第15章——消息流模式"},{"location":"/chapter-15/index.html#15-1-请求-响应模式","text":"代码清单15-1 服务器向发起请求的地址发送响应\npublic class Server {\n  static final int SERVER_PORT = 8888;\n\n  static public void main(String[] args) throws IOException {\n    // bind a socket for receiving packets\n    try (final DatagramSocket socket =\n        new DatagramSocket(SERVER_PORT)) {\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet1 =\n          new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet1);\n\n      final SocketAddress sender = packet1.getSocketAddress();\n      System.out.println(\"server: received \" +\n          new String(packet1.getData()));\n      System.out.println(\"server: sender was \" + sender);\n\n      // send response back\n      final byte[] response = \"got it!\".getBytes();\n      final DatagramPacket packet2 =\n          new DatagramPacket(response, response.length, sender);\n      socket.send(packet2);\n    }\n  }\n}\n代码清单15-2 客户端发送一个请求，然后阻塞直到接收到服务器的响应\npublic class Client {\n  static public void main(String[] args) throws IOException {\n    // get local socket with random port\n    try (final DatagramSocket socket = new DatagramSocket()) {\n\n      // send message to server\n      final byte[] request = \"hello\".getBytes();\n      final SocketAddress serverAddress =\n          new InetSocketAddress(\"localhost\", SERVER_PORT);\n      final DatagramPacket packet1 =\n          new DatagramPacket(request, request.length, serverAddress);\n      socket.send(packet1);\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet2 =\n          new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet2);\n\n      final SocketAddress sender = packet2.getSocketAddress();\n      System.out.println(\"client: received \" +\n          new String(packet2.getData()));\n      System.out.println(\"client: sender was \" + sender);\n    }\n  }\n}\nServer 的输出结果\nserver: received hello\nserver: sender was /127.0.0.1:55589\nClient 的可能输出结果\nclient: received got it!\nclient: sender was /127.0.0.1:8888\nHTTP Request Header\nGET /request?msg=hello HTTP/1.1\nHost: client-interface.our.application.domain\nAccept: application/json\nHTTP Response Header\nHTTP/1.1 200 OK\n...\nContent-Type: application/json\nContent-Length: 22\n{\"response\":\"got it!\"}\n代码清单15-3 使用Akka UntypedActor 来建模请求——响应模式\nobject RequestResponseActors {\n\n  case class Request(msg: String)\n  case class Response(msg: String)\n\n  class Responder extends Actor {\n    def receive: Receive = {\n      case Request(msg) ⇒\n        println(s\"got request: $msg\")\n        sender() ! Response(\"got it!\")\n    }\n  }\n\n  class Requester(responder: ActorRef) extends Actor {\n    responder ! Request(\"hello\")\n\n    def receive: Receive = {\n      case Response(msg) ⇒\n        println(s\"got response: $msg\")\n        context.system.terminate()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sys = ActorSystem(\"ReqRes\")\n    val responder = sys.actorOf(Props[Responder], \"responder\")\n    val requester = sys.actorOf(Props(new Requester(responder)), \"requester\")\n  }\n\n}\n运行结果\ngot request: hello\ngot response: got it!\n代码清单15-4 在请求消息中显式地包含响应地址\nobject RequestResponseTypedActors {\n\n  case class Request(msg: String, replyTo: ActorRef[Response])\n  case class Response(msg: String)\n\n  val responder: Behavior[Request] =\n    Static {\n      case Request(msg, replyTo) ⇒\n        println(s\"got request: $msg\")\n        replyTo ! Response(\"got it!\")\n    }\n\n  def requester(responder: ActorRef[Request]): Behavior[Response] =\n    SelfAware { self ⇒\n      responder ! Request(\"hello\", self)\n      Total {\n        case Response(msg) ⇒\n          println(s\"got response: $msg\")\n          Stopped\n      }\n    }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(\"ReqResTyped\", ContextAware[Unit] { ctx ⇒\n      val res = ctx.spawn(responder, \"responder\")\n      val req = ctx.watch(ctx.spawn(requester(res), \"requester\"))\n      Full {\n        case Sig(_, Terminated(`req`)) ⇒ Stopped\n      }\n    })\n  }\n}\n代码清单15-5 基于单向消息传递的请求——响应模式\nvar amqp = require('amqplib/callback_api');\namqp.connect('amqp://localhost', function(err, conn) {\n    conn.createChannel(function(err, ch) {\n        var q = 'rpc_queue';\n        ch.assertQueue(q, {durable: false});\n        ch.prefetch(1);\n        ch.consume(q, function reply(msg) {\n            console.log(\"got request: %s\", msg.content.toString());\n            ch.sendToQueue(msg.properties.replyTo,\n                new Buffer('got it!'),\n                {correlationId: msg.properties.correlationId});\n            ch.ack(msg);\n        });\n    });\n});\n代码清单15-6 监听与原始请求具有相同的关联ID的响应\nvar uuid = require('node-uuid');\namqp.connect('amqp://localhost', function(err, conn) {\n    conn.createChannel(function(err, ch) {\n        ch.assertQueue('responses', {}, function(err, q) {\n            var corr = uuid.v1();\n            ch.consume(q.queue, function(msg) {\n                if (msg.properties.correlationId === corr) {\n                    console.log('got response: %s', msg.content.toString());\n                    setTimeout(function() { conn.close(); process.exit(0) }, 500);\n                }\n            }, {noAck: true});\n            ch.sendToQueue('rpc_queue',\n                new Buffer('hello'),\n                { correlationId: corr, replyTo: q.queue });\n        });\n    });\n});","title":"15.1 请求——响应模式"},{"location":"/chapter-15/index.html#15-2-消息自包含模式","text":"SMTP\nS: 220 mailhost.example.com ESMTP Postfix\nC: HELO alice-workstation.example.com\nS: 250 Hello alice-workstation.example.com\nC: MAIL FROM:<alice@example.com>\nS: 250 Ok\nC: RCPT TO:<bob@example.com>\nS: 250 Ok\nC: DATA\nS: 354 End data with <CR><LF>.<CR><LF>\nC: From: \"Alice\" <alice@example.com>\nC: To: \"Bob\" <bob@example.com>\nC: Date: Fri, 23 October 2015 10:34:12 +0200\nC: Subject: lunch\nC:\nC: Hi Bob,\nC:\nC: sorry, I cannot make it, something else came up.\nC:\nC: Regards, Alice\nC: .\nS: 250 Ok, queued as 4567876345\nC: QUIT\nS: 221 Bye\n代码清单15-7 封装了多次 SMTP 交换所需要的信息\ncase class SendEmail(\n  sender:     String,\n  recipients: List[String],\n  body:       String, correlationID: UUID,\n  replyTo: ActorRef[SendEmailResult])\ncase class SendEmailResult(\n  correlationID: UUID,\n  status:        StatusCode,\n  explanation:   Option[String]) extends Result\n代码清单15-8 分离电子邮件主体，使得其可以按需投递\ncase class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])(body: Source[String]) extends StreamedRequest {\n  override def payload: Source[String] = body\n}\n代码清单15-9 允许邮件主体可以被接收者拉取\ncase class SendEmail(sender: String, recipients: List[String],\n                     bodyLocation:  URL,\n                     correlationID: UUID,\n                     replyTo:       ActorRef[SendEmailResult])","title":"15.2 消息自包含模式"},{"location":"/chapter-15/index.html#15-3-询问模式","text":"代码清单15-10 请求启动验证过程的简单协议\ncase class StartVerificationProcess(userEmail: String, replyTo: ActorRef[VerificationProcessResponse]) extends MyCommands\n\nsealed trait VerificationProcessResponse\n\ncase class VerificationProcessStarted(userEmail: String) extends VerificationProcessResponse\n\ncase class VerificationProcessFailed(userEmail: String) extends VerificationProcessResponse\n代码清单15-11 一个转发结果的匿名子Actor\ndef withChildActor(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware { ctx: ActorContext[StartVerificationProcess] ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val childActor = ctx.spawnAnonymous(FullTotal[Result] {\n          case Sig(ctx, PreStart) ⇒\n            ctx.setReceiveTimeout(5.seconds, ReceiveTimeout)\n            Same\n          case Msg(_, ReceiveTimeout) ⇒\n            log.warning(\n              \"verification process initiation timed out for {}\",\n              userEmail)\n            replyTo ! VerificationProcessFailed(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(`corrID`, StatusCode.OK, _)) ⇒\n            log.debug(\n              \"successfully started the verification process for {}\",\n              userEmail)\n            replyTo ! VerificationProcessStarted(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(`corrID`, StatusCode.Failed, explanation)) ⇒\n            log.info(\n              \"failed to start the verification process for {}: {}\",\n              userEmail, explanation)\n            replyTo ! VerificationProcessFailed(userEmail)\n            Stopped\n          case Msg(_, SendEmailResult(wrongID, _, _)) ⇒\n            log.error(\n              \"received wrong SendEmailResult for corrID {}\",\n              corrID)\n            Same\n        })\n        val request = SendEmail(\n          \"verification@example.com\",\n          List(userEmail),\n          constructBody(userEmail, corrID), corrID, childActor)\n        emailGateway ! request\n    }\n  }\n代码清单15-12 由询问模式所产生的Future，并进行了转换\ndef withAskPattern(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware { ctx ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n    implicit val timeout: Timeout = Timeout(5.seconds)\n    import ctx.executionContext\n    implicit val scheduler: Scheduler = ctx.system.scheduler\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val response: Future[SendEmailResult] =\n          emailGateway ? (SendEmail(\n            \"verification@example.com\",\n            List(userEmail),\n            constructBody(userEmail, corrID), corrID, _))\n        response.map {\n          case SendEmailResult(`corrID`, StatusCode.OK, _) ⇒\n            log.debug(\n              \"successfully started the verification process for {}\",\n              userEmail)\n            VerificationProcessStarted(userEmail)\n          case SendEmailResult(`corrID`, StatusCode.Failed, explanation) ⇒\n            log.info(\n              \"failed to start the verification process for {}: {}\",\n              userEmail, explanation)\n            VerificationProcessFailed(userEmail)\n          case SendEmailResult(wrongID, _, _) ⇒\n            log.error(\n              \"received wrong SendEmailResult for corrID {}\",\n              corrID)\n            VerificationProcessFailed(userEmail)\n        }.recover {\n          case _: AskTimeoutException ⇒\n            log.warning(\n              \"verification process initiation timed out for {}\",\n              userEmail)\n            VerificationProcessFailed(userEmail)\n        }.foreach(result ⇒ replyTo ! result)\n    }\n  }\n代码清单15-13 不使用内置支持实现询问模式\ndef withoutAskPattern(emailGateway: ActorRef[SendEmail]): Behavior[StartVerificationProcess] =\n  ContextAware[MyCommands] { ctx ⇒\n    val log = new BusLogging(\n      ctx.system.eventStream,\n      \"VerificationProcessManager\", getClass, ctx.system.logFilter)\n    var statusMap = Map.empty[UUID, (String, ActorRef[VerificationProcessResponse])]\n    val adapter = ctx.spawnAdapter((s: SendEmailResult) ⇒\n      MyEmailResult(s.correlationID, s.status, s.explanation))\n\n    Static {\n      case StartVerificationProcess(userEmail, replyTo) ⇒\n        val corrID = UUID.randomUUID()\n        val request = SendEmail(\n          \"verification@example.com\",\n          List(userEmail),\n          constructBody(userEmail, corrID), corrID, adapter)\n        emailGateway ! request\n        statusMap += corrID -> (userEmail, replyTo)\n        ctx.schedule(5.seconds, ctx.self,\n          MyEmailResult(corrID, StatusCode.Failed, Some(\"timeout\")))\n      case MyEmailResult(corrID, status, expl) ⇒\n        statusMap.get(corrID) match {\n          case None ⇒\n            log.error(\n              \"received SendEmailResult for unknown correlation ID {}\",\n              corrID)\n          case Some((userEmail, replyTo)) ⇒\n            status match {\n              case StatusCode.OK ⇒\n                log.debug(\n                  \"successfully started the verification process for {}\",\n                  userEmail)\n                replyTo ! VerificationProcessStarted(userEmail)\n              case StatusCode.Failed ⇒\n                log.info(\n                  \"failed to start the verification process for {}: {}\",\n                  userEmail, expl)\n                replyTo ! VerificationProcessFailed(userEmail)\n            }\n            statusMap -= corrID\n        }\n    }\n  }.narrow[StartVerificationProcess]","title":"15.3 询问模式"},{"location":"/chapter-15/index.html#15-5-聚合器模式","text":"代码清单15-14 使用for推导式来聚合三个Future表达式的结果。\ndef futureFrontPage(\n  themes:       ActorRef[GetTheme],\n  personalNews: ActorRef[GetPersonalNews],\n  topNews:      ActorRef[GetTopNews]): Behavior[GetFrontPage] =\n  ContextAware { ctx ⇒\n    import ctx.executionContext\n    implicit val timeout: Timeout = Timeout(1.second)\n    implicit val scheduler: Scheduler = ctx.system.scheduler\n\n    Static {\n      case GetFrontPage(user, replyTo) ⇒\n        val cssFuture =\n          (themes ? (GetTheme(user, _: ActorRef[ThemeResult])))\n            .map(_.css)\n            .recover {\n              case _: AskTimeoutException ⇒ \"default.css\"\n            }\n        val personalNewsFuture =\n          (personalNews ? (GetPersonalNews(\n            user,\n            _: ActorRef[PersonalNewsResult])))\n            .map(_.news)\n            .recover {\n              case _: AskTimeoutException ⇒ Nil\n            }\n        val topNewsFuture =\n          (topNews ? (GetTopNews(_: ActorRef[TopNewsResult])))\n            .map(_.news)\n            .recover {\n              case _: AskTimeoutException ⇒ Nil\n            }\n        for {\n          css ← cssFuture\n          personalNews ← personalNewsFuture\n          topNews ← topNewsFuture\n        } {\n          val topSet = topNews.toSet\n          val allNews = topNews ::: personalNews.filterNot(topSet.contains)\n          replyTo ! FrontPageResult(user, css, allNews)\n        }\n    }\n  }\n代码清单15-15 使用子Actor替代Future组合子的使用\nprivate def pf(p: PartialFunction[AnyRef, Unit]): p.type = p\n\ndef frontPage(\n  themes:       ActorRef[GetTheme],\n  personalNews: ActorRef[GetPersonalNews],\n  topNews:      ActorRef[GetTopNews]): Behavior[GetFrontPage] =\n  ContextAware { ctx ⇒\n    Static {\n      case GetFrontPage(user, replyTo) ⇒\n        val childRef = ctx.spawnAnonymous(Deferred { () ⇒\n          val builder = new FrontPageResultBuilder(user)\n          Partial[AnyRef](\n            pf {\n              case ThemeResult(css)         ⇒ builder.addCSS(css)\n              case PersonalNewsResult(news) ⇒ builder.addPersonalNews(news)\n              case TopNewsResult(news)      ⇒ builder.addTopNews(news)\n              case ReceiveTimeout           ⇒ builder.timeout()\n            } andThen { _ ⇒\n              if (builder.isComplete) {\n                replyTo ! builder.result\n                Stopped\n              } else Same\n            })\n        })\n        themes ! GetTheme(user, childRef)\n        personalNews ! GetPersonalNews(user, childRef)\n        topNews ! GetTopNews(childRef)\n        ctx.schedule(1.second, childRef, ReceiveTimeout)\n    }\n  }\n代码清单15-16 使用一个构建器来更加直接地表达领域模型\nclass FrontPageResultBuilder(user: String) {\n  private var css: Option[String] = None\n  private var personalNews: Option[List[String]] = None\n  private var topNews: Option[List[String]] = None\n\n  def addCSS(css: String): Unit = this.css = Option(css)\n\n  def addPersonalNews(news: List[String]): Unit =\n    this.personalNews = Option(news)\n\n  def addTopNews(news: List[String]): Unit =\n    this.topNews = Option(news)\n\n  def timeout(): Unit = {\n    if (css.isEmpty) css = Some(\"default.css\")\n    if (personalNews.isEmpty) personalNews = Some(Nil)\n    if (topNews.isEmpty) topNews = Some(Nil)\n  }\n\n  def isComplete: Boolean = css.isDefined &&\n    personalNews.isDefined && topNews.isDefined\n\n  def result: FrontPageResult = {\n    val topSet = topNews.get.toSet\n    val allNews = topNews.get :::\n      personalNews.get.filterNot(topSet.contains)\n    FrontPageResult(user, css.get, allNews)\n  }\n}\n代码清单15-17 添加第4个服务，降低了代码的可读性\nval overrideFuture =\n  (overrides ? (GetOverride(_: ActorRef[OverrideResult])))\n    .recover {\n      case _: AskTimeoutException ⇒ NoOverride\n    }\nfor {\n  css ← cssFuture\n  personalNews ← personalNewsFuture\n  topNews ← topNewsFuture\n  ovr ← overrideFuture\n} ovr match {\n  case NoOverride ⇒\n    val topSet = topNews.toSet\n    val allNews = topNews ::: personalNews.filterNot(topSet.contains)\n    replyTo ! FrontPageResult(user, css, allNews)\n  case other ⇒ // nothing to do here\n}\nfor {\n  ovr ← overrideFuture\n} ovr match {\n  case NoOverride ⇒ // nothing to do here\n  case Override(css, news) ⇒\n    replyTo ! FrontPageResult(user, css, news)\n}","title":"15.5 聚合器模式"},{"location":"/chapter-15/index.html#15-7-业务握手协议-又名可靠投递模式-","text":"代码清单15-18 使用Actor实现上面的（信息）交换\ncase class ChangeBudget(amount: BigDecimal, replyTo: ActorRef)\ncase object ChangeBudgetDone\ncase class CannotChangeBudget(reason: String)\n\nclass Sam(\n  alice:  ActorRef,\n  bob:    ActorRef,\n  amount: BigDecimal) extends Actor {\n  def receive: Receive = talkToAlice()\n\n  def talkToAlice(): Receive = {\n    alice ! ChangeBudget(-amount, self)\n    context.setReceiveTimeout(1.second)\n\n    LoggingReceive {\n      case ChangeBudgetDone           ⇒ context.become(talkToBob())\n      case CannotChangeBudget(reason) ⇒ context.stop(self)\n      case ReceiveTimeout             ⇒ alice ! ChangeBudget(-amount, self)\n    }\n  }\n\n  def talkToBob(): Receive = {\n    context.system.terminate()\n    Actor.emptyBehavior\n  }\n}\n\nclass Alice extends Actor {\n  var budget: BigDecimal = 10\n  var alreadyDone: Set[ActorRef] = Set.empty\n\n  def receive = LoggingReceive {\n    case ChangeBudget(amount, replyTo) if alreadyDone(replyTo) ⇒\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(amount, replyTo) if amount + budget > 0 ⇒\n      budget += amount\n      alreadyDone += replyTo\n      context.watch(replyTo)\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(_, replyTo) ⇒\n      replyTo ! CannotChangeBudget(\"insufficient budget\")\n    case Terminated(saga) ⇒\n      alreadyDone -= saga\n  }\n}\n代码清单15-19 向预算消息添加持久性\ncase class AliceConfirmedChange(deliveryId: Long)\ncase class AliceDeniedChange(deliveryId: Long)\n\nclass PersistentSam(\n  alice:                      ActorPath,\n  bob:                        ActorPath,\n  amount:                     BigDecimal,\n  override val persistenceId: String)\n  extends PersistentActor with AtLeastOnceDelivery with ActorLogging {\n\n  def receiveCommand: Actor.emptyBehavior.type = Actor.emptyBehavior\n\n  override def preStart(): Unit = {\n    context.become(talkToAlice())\n  }\n\n  def talkToAlice(): Receive = {\n    log.debug(\"talking to Alice\")\n    var deliveryId: Long = 0\n    deliver(alice)(id ⇒ {\n      deliveryId = id;\n      ChangeBudget(-amount, self, persistenceId)\n    })\n\n    LoggingReceive({\n      case ChangeBudgetDone ⇒\n        persist(AliceConfirmedChange(deliveryId)) { ev ⇒\n          confirmDelivery(ev.deliveryId)\n          context.become(talkToBob())\n        }\n      case CannotChangeBudget(reason) ⇒\n        persist(AliceDeniedChange(deliveryId)) { ev ⇒\n          confirmDelivery(ev.deliveryId)\n          context.stop(self)\n        }\n    }: Receive)\n  }\n\n  def talkToBob(): Actor.emptyBehavior.type = {\n    context.system.terminate()\n    Actor.emptyBehavior\n  }\n\n  def receiveRecover = LoggingReceive {\n    case AliceConfirmedChange(deliveryId) ⇒\n      confirmDelivery(deliveryId)\n      context.become(talkToBob())\n    case AliceDeniedChange(deliveryId) ⇒\n      confirmDelivery(deliveryId)\n      context.stop(self)\n  }\n}\n代码清单15-20 Alice Actor的持久化版本\ncase class BudgetChanged(amount: BigDecimal, persistenceId: String)\ncase object CleanupDoneList\ncase class ChangeDone(persistenceId: String)\n\nclass PersistentAlice extends PersistentActor with ActorLogging {\n  def persistenceId: String = \"Alice\"\n\n  implicit val mat: ActorMaterializer = ActorMaterializer()\n  import context.dispatcher\n\n  var alreadyDone: Set[String] = Set.empty\n  var budget: BigDecimal = 10\n\n  val cleanupTimer: Cancellable = context.system.scheduler.\n    schedule(1.hour, 1.hour, self, CleanupDoneList)\n\n  def receiveCommand = LoggingReceive {\n    case ChangeBudget(amount, replyTo, id) if alreadyDone(id) ⇒\n      replyTo ! ChangeBudgetDone\n    case ChangeBudget(amount, replyTo, id) if amount + budget > 0 ⇒\n      persist(BudgetChanged(amount, id)) { ev ⇒\n        budget += ev.amount\n        alreadyDone += ev.persistenceId\n        replyTo ! ChangeBudgetDone\n      }\n    case ChangeBudget(_, replyTo, _) ⇒\n      replyTo ! CannotChangeBudget(\"insufficient budget\")\n    case CleanupDoneList ⇒\n      val journal = PersistenceQuery(context.system)\n        .readJournalFor[LeveldbReadJournal](LeveldbReadJournal.Identifier)\n      for (persistenceId ← alreadyDone) {\n        val stream = journal\n          .currentEventsByPersistenceId(persistenceId)\n          .map(_.event)\n          .collect {\n            case AliceConfirmedChange(_) ⇒ ChangeDone(persistenceId)\n          }\n        stream.runWith(Sink.head).pipeTo(self)\n      }\n    case ChangeDone(id) ⇒\n      persist(ChangeDone(id)) { ev ⇒\n        alreadyDone -= ev.persistenceId\n      }\n  }\n\n  def receiveRecover = LoggingReceive {\n    case BudgetChanged(amount, id) ⇒\n      budget += amount\n      alreadyDone += id\n    case ChangeDone(id) ⇒\n      alreadyDone -= id\n  }\n\n  override def postStop(): Unit = {\n    cleanupTimer.cancel()\n  }\n}","title":"15.7 业务握手协议（又名可靠投递模式）"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"","title":"第16章——流控制模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"","title":"第17章——状态管理和持久化模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"},{"location":"/extras.html","text":"","title":"额外指引 ·"},{"location":"/extras.html#额外指引","text":"Netty In Action In Scala","title":"额外指引"},{"location":"/errata.html","text":"","title":"勘误 ·"},{"location":"/errata.html#勘误","text":"TODO","title":"勘误"}]}