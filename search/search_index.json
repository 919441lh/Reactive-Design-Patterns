{"docs":[{"location":"/index.html","text":"目录 内容提要 第一部分 简介 第1章——为什么需要反应式 第2章——反应式宣言概览 第3章——行业工具 第二部分 微言大义 第4章——消息传递 第5章——位置透明性 第6章——分而治之 第7章——原则化的失败处理 第8章——有限定的一致性 第9章——按需的不确定性 第三部分 设计模式 第10章——消息流 第11章——测试反应式应用程序 第12章——容错及恢复模式 第13章——复制模式 第14章——资源管理模式 第15章——消息流模式 第16章——流控制模式 第17章——状态管理和持久化模式 附录A——图解反应式系统 附录B——图解示例 附录C——反应式宣言 额外指引 勘误\n《反应式设计模式》\n原书名《Reactive Design Patterns》\n一本有关反应式（Reactive）系统设计的模式书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/abstract.html","text":"","title":"内容提要 ·"},{"location":"/abstract.html#内容提要","text":"TODO","title":"内容提要"},{"location":"/part1.html","text":"","title":"第一部分 简介 ·"},{"location":"/part1.html#第一部分-简介","text":"你有曾思考过高性能Web应用程序是如何实现的吗？社交网络和大型零售网站肯定有一些秘密配方使得系统运行迅速并且可靠，但这些秘密是什么呢？在这本书中，我们将为你揭晓谜底，你将学习到这些近似永远不出故障，并且能够满足数十亿人需要的系统背后的设计原则与模式。虽然你所构建的系统未必有如此雄心壮志的要求，但是它们主要的特质应该是一致的：\n你想要你的应用程序可靠地工作，即使某些部件（硬件或者软件）有可能出现故障。\n你希望你的应用程序在你需要支撑更多的用户时，可以持续地提供服务，而且你希望能够通过添加或者删除资源来调整它的能力，从而适应不断变化的需求（没有可以预测未来的水晶球的帮助，很难进行正确的容量规划）。\n在第1章中，我们将勾勒出一个具备这些特质的应用程序的开发过程。我们将指明你会遇到的挑战，并基于一个具体的例子（一个假想中的Gmail服务实现）给出解决方案，但是我们将会以不提供具体的技术选型的形式进行。\n这个使用场景为接下来在第2章中对《反应式宣言》所进行的详细讨论作了铺垫。该宣言以简洁、抽象的形式撰写，目的是为了聚焦于它的本质：将多个独立的、有效的程序特性凝聚为一个整体，从而形成更大的合力。我们将通过把高度抽象的特质分解为更小的部分，并解释各部分又是如何合回一体的过程，来展现这一点。\n我们将会以第3章结束这一部分，其大致地介绍了行业工具：函数式编程、Future 和 Promise、通信顺序进程（CSP）、 Observer 和 Observable（Reactive Extensions）以及 Actor 模型。","title":"第一部分 简介"},{"location":"/chapter-01/index.html","text":"","title":"第1章——为什么需要反应式 ·"},{"location":"/chapter-01/index.html#第1章-为什么需要反应式","text":"","title":"第1章——为什么需要反应式"},{"location":"/chapter-02/index.html","text":"","title":"第2章——反应式宣言概览 ·"},{"location":"/chapter-02/index.html#第2章-反应式宣言概览","text":"","title":"第2章——反应式宣言概览"},{"location":"/chapter-02/index.html#代码清单2-1","text":"Listing 2.1 Excerpt from a simple controller for an image service\npublic interface Images {\n  Image get(String Key);\n\n  void add(String key, Image image);\n}\n\npublic Images cache;\npublic Images database;\n\npublic Image retrieveImages(String key) {\n  Image result = cache.get(key);\n  if (result != null) {\n    return result;\n  } else {\n    result = database.get(key);\n    if (result != null) {\n      cache.add(key, result);\n      return result;\n    } else {\n      return fallback;\n    }\n  }\n}","title":"代码清单2-1"},{"location":"/chapter-02/index.html#代码清单2-2","text":"val result = f(42)","title":"代码清单2-2"},{"location":"/chapter-02/index.html#代码清单2-3","text":"ReplyA a = computeA();\nReplyB b = computeB();\nReplyC c = computeC();\n\nResult r = aggregate(a, b, c);","title":"代码清单2-3"},{"location":"/chapter-02/index.html#代码清单2-4","text":"Future<ReplyA> a = taskA();\nFuture<ReplyB> b = taskB();\nFuture<ReplyC> c = taskC();\n\nResult r = aggregate(a.get(), b.get(), c.get());","title":"代码清单2-4"},{"location":"/chapter-02/index.html#代码清单2-5","text":"val fa: Future[ReplyA] = taskA()\nval fb: Future[ReplyB] = taskB()\nval fc: Future[ReplyC] = taskC()\n\nval fr: Future[Result] = for (a ← fa; b ← fb; c ← fc)\n  yield aggregate(a, b, c)","title":"代码清单2-5"},{"location":"/chapter-02/index.html#代码清单2-6","text":"final Socket socket = new Socket(\"127.0.0.1\", 8080);\nsocket.getOutputStream().write(requestMessageBytes);\nfinal int bytesRead = socket.getInputStream().read(responseBuffer);","title":"代码清单2-6"},{"location":"/chapter-02/index.html#代码清单2-7","text":"CompletionStage<Response> future =\n        ask(actorRef, request, timeout)\n                .thenApply(Response.class::cast);\nfuture.thenAccept(response -> AskActorWithJava8.processIt(response));","title":"代码清单2-7"},{"location":"/chapter-02/index.html#代码清单2-8","text":"try {\n  f(i)\n} catch {\n  case _: java.lang.ArithmeticException ⇒ Int.MaxValue\n  case ex: java.lang.StackOverflowError ⇒ ???\n  case ex: java.net.ConnectException    ⇒ ???\n}","title":"代码清单2-8"},{"location":"/chapter-03/index.html","text":"","title":"第3章——行业工具 ·"},{"location":"/chapter-03/index.html#第3章-行业工具","text":"","title":"第3章——行业工具"},{"location":"/chapter-03/index.html#3-2-函数式编程","text":"代码清单3-1 不安全的、可变的消息类，可能会隐含非预期的行为\nimport java.util.Date;\n\npublic class Unsafe {\n  private Date timestamp;\n  private final StringBuffer message;\n\n  public Unsafe(Date timestamp, StringBuffer message) {\n    this.timestamp = timestamp;\n    this.message = message;\n  }\n\n  public synchronized Date getTimestamp() {\n    return timestamp;\n  }\n\n  public synchronized void setTimestamp(Date timestamp) {\n    this.timestamp = timestamp;\n  }\n\n  public StringBuffer getMessage() {\n    return message;\n  }\n}\n代码清单 3-2 不可变的消息类，其行为是可预知的，并易于推断\nimport java.util.Date;\n\npublic class Immutable {\n  private final Date timestamp;\n  private final String message;\n\n  public Immutable(final Date timestamp, final String message) {\n    this.timestamp = new Date(timestamp.getTime());\n    this.message = message;\n  }\n\n  public Date getTimestamp() {\n    return new Date(timestamp.getTime());\n  }\n\n  public String getMessage() {\n    return message;\n  }\n}\nMessage.scala\nimport java.util.Date\n\ncase class Message(timestamp: Date, message: String)\nUsingStringBuffer.java\nfinal StringBuffer original = new StringBuffer(\"foo\");\nfinal StringBuffer reversed = original.reverse();\nSystem.out.println(String.format(\n    \"original '%s', new value '%s'\",\n    original,\n    reversed));\n代码清单 3-3 引用透明性：允许代换预先计算好的值\npublic class Rooter {\n  private final double value;\n  private Double root = null;\n\n  public Rooter(double value) {\n    this.value = value;\n  }\n\n  public double getValue() {\n    return value;\n  }\n\n  public double getRoot() {\n    if (root == null) {\n      root = Math.sqrt(value);\n    }\n    return root;\n  }\n}\n代码清单3-4 因副作用而受限的可用性\npublic class SideEffecting implements Serializable, Cloneable {\n  private int count;\n\n  public SideEffecting(int start) {\n    this.count = start;\n  }\n\n  public int next() {\n    this.count += Math.incrementExact(this.count);\n    return this.count;\n  }\n}\nIntSeeding.java\nfinal int next = se.next();\nif (logger.isDebugEnabled()) {\n  logger.debug(\"Next is \" + se.next());\n}\nreturn next;\nUsingMapFunction.java\nfinal List<Integer> numbers = Arrays.asList(1, 2, 3);\nfinal List<Integer> numbersPlusOne =\n        numbers.stream()\n                .map(number -> number + 1)\n                .collect(Collectors.toList());\nPython REPL\n>>> def addOne(x):\n... returnx+1\n...\n>>> myFunction = addOne\n>>> myFunction(3)\n4","title":"3.2 函数式编程"},{"location":"/chapter-03/index.html#3-4-对反应式设计的现有支持","text":"sample.js\nvar http = require('http');\n\nvar counter = 0;\n\nhttp.createServer(function (req, res) {\n  counter++;\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Sending response: ' + counter + ' via callback!\\n');\n}).listen(8888, '127.0.0.1');\n\nconsole.log('Server up on 127.0.0.1:8888, send requests!');\nsample.go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n\titerations := 10\n    myChannel := make(chan int)\n\n    go producer(myChannel, iterations)\n    go consumer(myChannel, iterations)\n\n    time.Sleep(500 * time.Millisecond)\n}\n\nfunc producer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        fmt.Println(\"Sending: \", i)\n        myChannel <- i\n    }   \n}\n\nfunc consumer(myChannel chan int, iterations int) {\n    for i := 1; i <= iterations; i++ {\n        recVal := <-myChannel\n        fmt.Println(\"Received: \", recVal)\n    }   \n}\n代码清单3-5 从更快的数据源获取结果\npublic class ParallelRetrievalExample {\n  private final CacheRetriever cacheRetriever;\n  private final DBRetriever dbRetriever;\n\n  ParallelRetrievalExample(CacheRetriever cacheRetriever,\n      DBRetriever dbRetriever) {\n    this.cacheRetriever = cacheRetriever;\n    this.dbRetriever = dbRetriever;\n  }\n\n  public Object retrieveCustomer(final long id) {\n        final CompletableFuture<Object> cacheFuture = CompletableFuture\n                .supplyAsync(() -> cacheRetriever.getCustomer(id));\n        final CompletableFuture<Object> dbFuture = CompletableFuture\n                .supplyAsync(() -> dbRetriever.getCustomer(id));\n\n        return CompletableFuture.anyOf(cacheFuture, dbFuture);\n    }\n}\n代码清单3-6 使用Scala编程语言将两个Future的结果组合为单一结果\ndef getProductInventoryByPostalCode(\n  productSku: Long,\n  postalCode: String): Future[(Long, Map[String, Long])] = {\n  // Import the duration DSL to be used in the timeout\n  import scala.concurrent.duration._\n\n  // Provide the thread pool and Future timeout value to be applied\n  implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(new ForkJoinPool())\n  implicit val timeout: FiniteDuration = 250 milliseconds\n\n  // Define the futures so they can start doing their work\n  val localInventoryFuture = Future {\n    inventoryService.currentInventoryInWarehouse(\n      productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = Future {\n    inventoryService.currentInventoryOverallByWarehouse(\n      productSku)\n  }\n\n  // Retrieve the values and return a future of the combined result\n  for {\n    local ← localInventoryFuture\n    overall ← overallInventoryFutureByWarehouse\n  } yield (local, overall)\n}\nStagedFuturesAsyncExample.scala\nimport scala.async.Async.{ async, await }\nval resultFuture = async {\n  val localInventoryFuture = async {\n    inventoryService.currentInventoryInWarehouse(productSku, postalCode)\n  }\n  val overallInventoryFutureByWarehouse = async {\n    inventoryService.currentInventoryOverallByWarehouse(productSku)\n  }\n  (await(localInventoryFuture), await(overallInventoryFutureByWarehouse))\n}\nRxJavaExample.java\npackage chapter03.rxjava;\n\nimport io.reactivex.Observable;\n\npublic class RxJavaExample {\n  public void observe(String[] strings) {\n        Observable.fromArray(strings).subscribe((s) -> {\n                System.out.println(\"Received \" + s);\n        });\n    }\n}\nRxJavaExampleDriver.java\npackage chapter03.rxjava;\n\npublic class RxJavaExampleDriver {\n  private static final RxJavaExample rxJavaExample = new RxJavaExample();\n\n  public static void main(String[] args) {\n    String[] strings = {\"a\", \"b\", \"c\"};\n    rxJavaExample.observe(strings);\n  }\n}\n代码清单3-7 一个使用 Akka 的Actor的例子\npackage chapter03.actor\n\nimport akka.actor._\nimport akka.actor.SupervisorStrategy.Restart\nimport akka.event.LoggingReceive\n\ncase object Start\ncase class CounterMessage(counterValue: Int)\ncase class CounterTooLargeException(message: String) extends Exception(message)\n\nclass SupervisorActor extends Actor with ActorLogging {\n  override val supervisorStrategy: OneForOneStrategy = OneForOneStrategy() {\n    case _: CounterTooLargeException ⇒ Restart\n  }\n\n  private val actor2 = context.actorOf(Props[SecondActor], \"second-actor\")\n  private val actor1 = context.actorOf(Props(new FirstActor(actor2)), \"first-actor\")\n\n  def receive: PartialFunction[Any, Unit] = {\n    case Start ⇒ actor1 ! Start\n  }\n}\n\nclass AbstractCounterActor extends Actor with ActorLogging {\n  protected var counterValue = 0\n\n  def receive: PartialFunction[Any, Unit] = {\n    case _ ⇒\n  }\n\n  def counterReceive: Receive = LoggingReceive {\n    case CounterMessage(i) if i <= 1000 ⇒\n      counterValue = i\n      log.info(s\"Counter value: $counterValue\")\n      sender ! CounterMessage(counterValue + 1)\n    case CounterMessage(_) ⇒\n      throw CounterTooLargeException(\n        \"Exceeded max value of counter!\")\n  }\n\n  override def postRestart(reason: Throwable): Unit = {\n    context.parent ! Start\n  }\n}\n\nclass FirstActor(secondActor: ActorRef) extends AbstractCounterActor {\n  override def receive = LoggingReceive {\n    case Start ⇒\n      context.become(counterReceive)\n      log.info(\"Starting counter passing.\")\n      secondActor ! CounterMessage(counterValue + 1)\n  }\n}\n\nclass SecondActor() extends AbstractCounterActor {\n  override def receive: Receive = counterReceive\n}\n\nobject Example extends App {\n  val system = ActorSystem(\"counter-supervision-example\")\n  val supervisor = system.actorOf(Props[SupervisorActor])\n  supervisor ! Start\n}","title":"3.4 对反应式设计的现有支持"},{"location":"/part2.html","text":"","title":"第二部分 微言大义 ·"},{"location":"/part2.html#第二部分-微言大义","text":"这本书的第一部分综述了反应式系统的价值。你看到了对用户输入总是保持回弹性和可伸缩性的需要，从而即使在失败和不同负载的情况下也能保持即时响应性。在我们探索这些可取的属性过程中，你得出了需要使用消息驱动来作为底层实现的必要性。\n第二部分对反应式的 4 个特质进行了补充说明：提出了一组构建反应式架构的构建块。这一部分的重点是如何做到反应式，而第一部分则描述了我们要实现的目标及缘由。在这一部分所讨论的指导原则，以及我们在第3章中所介绍的行业工具，一起构成了第三部分中多种模式的基础。\n我们决定以一种连贯、凝聚的方式组织这些材料，以便你在构建反应式应用程序的过程中，推敲你自己的模式设计时，本书可以方便地作为一个紧凑的参考。作为一个完整的反应式架构的360度全景，这一部分涵盖了大量的基础理论。你可能想要先阅读第4章，然后略读这一部分的其余章节，并在你研究这本书第三部分中所介绍的相应模式时，再回过头来细细研读这部分中的对应章节。\n在这一部分中，你将学习到：\n通过显式的异步消息传递来使得封装和隔离成为可能； 通过位置透明性，提高组合能力，并添加水平扩展能力； 应用分而治之（divide et regna），以层级化模块的形式组织系统； 这个层级结构如何使得原则化的失败处理成为可能； 在分布式系统中实现足够一致的程序语义； 尽可能地避免不确定性，并在必要时添加； 使用基于消息流的拓扑指导反应式应用程序设计。","title":"第二部分 微言大义"},{"location":"/chapter-04/index.html","text":"","title":"第4章——消息传递 ·"},{"location":"/chapter-04/index.html#第4章-消息传递","text":"","title":"第4章——消息传递"},{"location":"/chapter-05/index.html","text":"","title":"第5章——位置透明性 ·"},{"location":"/chapter-05/index.html#第5章-位置透明性","text":"","title":"第5章——位置透明性"},{"location":"/chapter-06/index.html","text":"","title":"第6章——分而治之 ·"},{"location":"/chapter-06/index.html#第6章-分而治之","text":"上一章假定程序通常由多个组件构成，这些组件以某种方式分离：由不同的团队开发不同的功能领域；通过接口访问模块；模块被打包成容易被替换的方式；等等。在过去的几十年间，我们花费了大量的精力在编程语言中定义模块的语法和语义上，以及用于部署他们的库和基础设施。重要的问题是，我们应该如何划分一个问题，从而成功地解决它呢？\n本章无代码清单","title":"第6章——分而治之"},{"location":"/chapter-07/index.html","text":"","title":"第7章——原则化的失败处理 ·"},{"location":"/chapter-07/index.html#第7章-原则化的失败处理","text":"","title":"第7章——原则化的失败处理"},{"location":"/chapter-08/index.html","text":"","title":"第8章——有限定的一致性 ·"},{"location":"/chapter-08/index.html#第8章-有限定的一致性","text":"","title":"第8章——有限定的一致性"},{"location":"/chapter-09/index.html","text":"","title":"第9章——按需的不确定性 ·"},{"location":"/chapter-09/index.html#第9章-按需的不确定性","text":"这一章为全书最抽象的部分，对于初步理解后面章节来说，这一章的内容并非必需。你可以先直接跳到第10章看看，只要你保证之后还会回来。","title":"第9章——按需的不确定性"},{"location":"/chapter-09/index.html#9-2-函数式反应式编程","text":"f(x) = x + 1\ng(x) = x - 1\nh(x) = f(x) - g(x)","title":"9.2 函数式反应式编程"},{"location":"/part3.html","text":"","title":"第三部分 设计模式 ·"},{"location":"/part3.html#第三部分-设计模式","text":"到目前为止，我们在讨论什么是反应式，以及为什么要应用反应式上已经花费了不少时间。现在是时候关注如何应用反应式了。 在第三部分中，我们将介绍一些可以帮助你实现反应式应用程序的设计模式。我们将首先讨论如何进行测试，以确保你的应用程序是反应式的，这样你就可以有信心接下来的的应用构建是都满足反应式契约的：无论从最小的功能组件，还是到整个跨数据中心部署结构。 然后，我们将深入探讨一些在反应式概念的各个维度上构建反应式系统的特定模式。\n在这一部分中，你将学习到以下内容：\n测试反应式系统，并特别强调异步测试 将内部和外部容错应用到你的应用程序中 管理反应式应用程序的资源 管理应用程序内部及应用程序之间的消息和数据流通 管理反应式系统的状态，以及持久化数据的过程\n对于每一个模式，我们将先以一个简短的段落介绍它的本质（以便回顾时作参考），接着介绍模式会出现在系统中的场景，并给出一个将模式应用到具体问题的详细示例。然后总结出每个模式所能解决的问题、典型特征和适用范围。\n第二部分讨论了搭建反应式系统的基础构建块，在你阅读后续章节时，值得经常回顾第二部分中的相关背景——以我们的经验，通常对一个主题进行二次攻关才会带来灵光乍现的瞬间","title":"第三部分 设计模式"},{"location":"/chapter-10/index.html","text":"","title":"第10章——消息流 ·"},{"location":"/chapter-10/index.html#第10章-消息流","text":"","title":"第10章——消息流"},{"location":"/chapter-11/index.html","text":"","title":"第11章——测试反应式应用程序 ·"},{"location":"/chapter-11/index.html#第11章-测试反应式应用程序","text":"","title":"第11章——测试反应式应用程序"},{"location":"/chapter-11/index.html#代码清单11-1","text":"Listing 11.1 Testing a purely synchronous translation function\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\ntranslate(input) should be(output)","title":"代码清单11-1"},{"location":"/chapter-11/index.html#代码清单11-2","text":"val input = \"Hur mår du?\"\nval output = \"How are you?\"\nval future = translate(input)\n// what now?","title":"代码清单11-2"},{"location":"/chapter-11/index.html#代码清单11-3","text":"val input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\n// when can we continue?","title":"代码清单11-3"},{"location":"/chapter-11/index.html#代码清单11-4","text":"while (!future.isCompleted) Thread.sleep(50)","title":"代码清单11-4"},{"location":"/chapter-11/index.html#代码清单11-5","text":"var i = 20\nwhile (!future.isCompleted && i > 0) {\n  i -= 1\n  Thread.sleep(50)\n}\nif (i == 0) fail(\"translation was not received in time\")","title":"代码清单11-5"},{"location":"/chapter-11/index.html#代码清单11-6","text":"Listing 11.2 Awaiting the result blocks synchronously on the translation\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval result = Await.result(translate(input), 1.second)\nresult should be(output)","title":"代码清单11-6"},{"location":"/chapter-11/index.html#代码清单11-7","text":"Listing 11.3 Expecting replies with a TestProbe\nval input = \"Hur mår du?\"\nval output = \"How are you?\"\nval probe = TestProbe()\ntranslationService ! Translate(input, probe.ref)\nprobe.expectMsg(1.second, output)","title":"代码清单11-7"},{"location":"/chapter-11/index.html#代码清单11-8","text":"Listing 11.4 Using a TestProbe to receive the response from the scheduler\nval probe = TestProbe()\nval start = Timestamp.now\nscheduler ! Schedule(probe.ref, \"tick\", 1.second)\nprobe.expectMsg(2.seconds, \"tick\")\nval stop = Timestamp.now\nval duration = stop - start\nassert(duration > 950.millis, \"tick came in early\")\nassert(duration < 1050.millis, \"tick came in late\")\n// when can we continue?","title":"代码清单11-8"},{"location":"/chapter-11/index.html#代码清单11-9","text":"Listing 11.5 Determining 95th percentile latency\nval probe = TestProbe()\nval echo = echoService(\"keepSLA\")\nval N = 200\nval timings = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  echo ! Request(string, probe.ref)\n  probe.expectMsg(100.millis, s\"test run $i\", Response(string))\n  val stop = Timestamp.now\n  stop - start\n}\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 25.milliseconds else 1.millisecond\nninetyfifthPercentile.toFiniteDuration should be <= SLA","title":"代码清单11-9"},{"location":"/chapter-11/index.html#代码清单11-10","text":"Listing 11.6 Generating the test samples in parallel with the Ask pattern\nval echo = echoService(\"keepSLAfuture\")\nval N = 10000\nval timingFutures = for (i ← 1 to N) yield {\n  val string = s\"test$i\"\n  val start = Timestamp.now\n  (echo ? (Request(string, _))) collect {\n    case Response(`string`) ⇒ Timestamp.now - start\n  }\n}\nval futureOfTimings = Future.sequence(timingFutures)\nval timings = Await.result(futureOfTimings, 5.seconds)\n// discard top 5%\nval sorted = timings.sorted\nval ninetyfifthPercentile = sorted.dropRight(N * 5 / 100).last\ninfo(s\"SLA min=${sorted.head} max=${sorted.last} 95th=$ninetyfifthPercentile\")\nval SLA = if (Helpers.isCiTest) 500.milliseconds else 100.milliseconds\nninetyfifthPercentile.toFiniteDuration should be < SLA","title":"代码清单11-10"},{"location":"/chapter-11/index.html#代码清单11-12","text":"Listing 11.8 Verifying that no additional messages are received\nimport scala.concurrent.duration._\nval scheduler = system.actorOf(Scheduler.props)\n\nval probe = TestProbe()\nscheduler ! ScheduleRepeatedly(probe.ref, 1.second, \"tick\")\nval token = probe.expectMsgType[SchedulerToken]\nprobe.expectMsg(1500.millis, \"tick\")\nscheduler ! CancelSchedule(token, probe.ref)\nprobe.expectMsg(100.millis, ScheduleCanceled)\nprobe.expectNoMessage(2.seconds)","title":"代码清单11-12"},{"location":"/chapter-11/index.html#代码清单11-13","text":"Listing 11.9 Matching responses to requests with a correlation ID\nval ingestService = system.actorOf(DataIngester.props)\nval probe = TestProbe()\ningestService ! Retrieve(url, \"myID\", probe.ref)\nval replies = probe.receiveWhile(1.second) {\n  case r @ Record(\"myID\", _) ⇒ r\n}\nprobe.expectMsg(0.seconds, EOF)","title":"代码清单11-13"},{"location":"/chapter-12/index.html","text":"","title":"第12章——容错及恢复模式 ·"},{"location":"/chapter-12/index.html#第12章-容错及恢复模式","text":"在这一章中，你将学习到在设计应用程序时如何应对失败出现的可能性。我们将通过具体地构建一个具有回弹性的计算引擎来演示几个相应的模式，这个系统允许提交批处理作业，并在有着弹性调度的硬件资源上执行。我们将基于你在第6章和第7章所学习到的知识进行展开，因此，你可能想要回顾一下之前的内容。","title":"第12章——容错及恢复模式"},{"location":"/chapter-12/index.html#12-4-断路器模式","text":"代码清单 12-1 利用断路器使得失败组件有时间恢复\nprivate object StorageFailed extends RuntimeException\n\nprivate def sendToStorage(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  val f: Future[StorageStatus] = ???\n  f.map {\n    case StorageStatus.Failed => throw StorageFailed\n    case other => other\n  }\n}\n\nimport scala.concurrent.duration._\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  5,\n  300.millis,\n  30.seconds,\n)\n\ndef persist(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(sendToStorage(job))\n    .recover {\n      case StorageFailed => StorageStatus.Failed\n      case _: TimeoutException => StorageStatus.Unknown\n      case _: CircuitBreakerOpenException => StorageStatus.Failed\n    }\n}\n代码清单12-2 使用速率限制器保护组件\nimport scala.concurrent.Future\nimport scala.concurrent.duration.{ Deadline, FiniteDuration }\n\ncase object RateLimitExceeded extends RuntimeException\n\nclass RateLimiter(requests: Int, period: FiniteDuration) {\n  private val startTimes = {\n    val onePeriodAgo = Deadline.now - period\n    Array.fill(requests)(onePeriodAgo)\n  }\n  private var position = 0\n  private def lastTime = startTimes(position)\n  private def enqueue(time: Deadline): Unit = {\n    startTimes(position) = time\n    position += 1\n    if (position == requests) position = 0\n  }\n  def call[T](block: ⇒ Future[T]): Future[T] = {\n    val now = Deadline.now\n    if ((now - lastTime) < period) {\n      Future.failed(RateLimitExceeded)\n    } else {\n      enqueue(now)\n      block\n    }\n  }\n}\n代码清单12-3 断路器：限制来自同一个客户端的请求\nprivate val limiter = new RateLimiter(100, 2.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  limiter\n    .call(persist(job))\n    .recover {\n      case RateLimitExceeded ⇒ StorageStatus.Failed\n    }\n}\n代码清单12-4 门控一个客户端\nprivate val limiter = new RateLimiter(100, 2.seconds)\nprivate val breaker = CircuitBreaker(\n  system.scheduler,\n  10, Duration.Zero, 10.seconds)\n\ndef persistForThisClient(job: Job): Future[StorageStatus] = {\n  import akka.rdpextras.ExecutionContexts.sameThreadExecutionContext\n  breaker\n    .withCircuitBreaker(limiter.call(persist(job)))\n    .recover {\n      case RateLimitExceeded              ⇒ StorageStatus.Failed\n      case _: CircuitBreakerOpenException ⇒ StorageStatus.Gated\n    }\n}","title":"12.4. 断路器模式"},{"location":"/chapter-13/index.html","text":"","title":"第13章——复制模式 ·"},{"location":"/chapter-13/index.html#第13章-复制模式","text":"","title":"第13章——复制模式"},{"location":"/chapter-14/index.html","text":"","title":"第14章——资源管理模式 ·"},{"location":"/chapter-14/index.html#第14章-资源管理模式","text":"","title":"第14章——资源管理模式"},{"location":"/chapter-15/index.html","text":"","title":"第15章——消息流模式 ·"},{"location":"/chapter-15/index.html#第15章-消息流模式","text":"","title":"第15章——消息流模式"},{"location":"/chapter-15/index.html#代码清单15-1","text":"Listing 15.1 Server responding to the address that originated the request\npublic class Server {\n  static final int SERVER_PORT = 8888;\n\n  static public void main(String[] args) throws IOException {\n    // bind a socket for receiving packets\n    try (final DatagramSocket socket =\n        new DatagramSocket(SERVER_PORT)) {\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet1 =\n          new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet1);\n\n      final SocketAddress sender = packet1.getSocketAddress();\n      System.out.println(\"server: received \" +\n          new String(packet1.getData()));\n      System.out.println(\"server: sender was \" + sender);\n\n      // send response back\n      final byte[] response = \"got it!\".getBytes();\n      final DatagramPacket packet2 =\n          new DatagramPacket(response, response.length, sender);\n      socket.send(packet2);\n    }\n  }\n}","title":"代码清单15-1"},{"location":"/chapter-15/index.html#代码清单15-2","text":"Listing 15.2 Client sending a request and then blocking until the server responds\npublic class Client {\n  static public void main(String[] args) throws IOException {\n    // get local socket with random port\n    try (final DatagramSocket socket = new DatagramSocket()) {\n\n      // send message to server\n      final byte[] request = \"hello\".getBytes();\n      final SocketAddress serverAddress =\n          new InetSocketAddress(\"localhost\", SERVER_PORT);\n      final DatagramPacket packet1 =\n          new DatagramPacket(request, request.length, serverAddress);\n      socket.send(packet1);\n\n      // receive one packet\n      final byte[] buffer = new byte[1500];\n      final DatagramPacket packet2 =\n          new DatagramPacket(buffer, buffer.length);\n      socket.receive(packet2);\n\n      final SocketAddress sender = packet2.getSocketAddress();\n      System.out.println(\"client: received \" +\n          new String(packet2.getData()));\n      System.out.println(\"client: sender was \" + sender);\n    }\n  }\n}\nServer 的输出结果\nserver: received hello\nserver: sender was /127.0.0.1:55589\nClient 的可能输出结果\nclient: received got it!\nclient: sender was /127.0.0.1:8888\nHTTP Request Header\nGET /request?msg=hello HTTP/1.1\nHost: client-interface.our.application.domain\nAccept: application/json\nHTTP Response Header\nHTTP/1.1 200 OK\n...\nContent-Type: application/json\nContent-Length: 22\n{\"response\":\"got it!\"}","title":"代码清单15-2"},{"location":"/chapter-15/index.html#代码清单15-3","text":"Listing 15.3 Untyped Akka Actors modeling request–response\nobject RequestResponseActors {\n\n  case class Request(msg: String)\n  case class Response(msg: String)\n\n  class Responder extends Actor {\n    def receive: Receive = {\n      case Request(msg) ⇒\n        println(s\"got request: $msg\")\n        sender() ! Response(\"got it!\")\n    }\n  }\n\n  class Requester(responder: ActorRef) extends Actor {\n    responder ! Request(\"hello\")\n\n    def receive: Receive = {\n      case Response(msg) ⇒\n        println(s\"got response: $msg\")\n        context.system.terminate()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sys = ActorSystem(\"ReqRes\")\n    val responder = sys.actorOf(Props[Responder], \"responder\")\n    val requester = sys.actorOf(Props(new Requester(responder)), \"requester\")\n  }\n\n}\n运行结果\ngot request: hello\ngot response: got it!","title":"代码清单15-3"},{"location":"/chapter-15/index.html#代码清单15-4","text":"Listing 15.4 Including the response explicitly in the request message\nobject RequestResponseTypedActors {\n\n  case class Request(msg: String, replyTo: ActorRef[Response])\n  case class Response(msg: String)\n\n  val responder: Behavior[Request] =\n    Static {\n      case Request(msg, replyTo) ⇒\n        println(s\"got request: $msg\")\n        replyTo ! Response(\"got it!\")\n    }\n\n  def requester(responder: ActorRef[Request]): Behavior[Response] =\n    SelfAware { self ⇒\n      responder ! Request(\"hello\", self)\n      Total {\n        case Response(msg) ⇒\n          println(s\"got response: $msg\")\n          Stopped\n      }\n    }\n\n  def main(args: Array[String]): Unit = {\n    ActorSystem(\"ReqResTyped\", ContextAware[Unit] { ctx ⇒\n      val res = ctx.spawn(responder, \"responder\")\n      val req = ctx.watch(ctx.spawn(requester(res), \"requester\"))\n      Full {\n        case Sig(_, Terminated(`req`)) ⇒ Stopped\n      }\n    })\n  }\n}","title":"代码清单15-4"},{"location":"/chapter-15/index.html#代码清单15-5","text":"Listing 15.5 Request–response based on a one-way messaging protocol\nvar amqp = require('amqplib/callback_api');\namqp.connect('amqp://localhost', function(err, conn) {\n    conn.createChannel(function(err, ch) {\n        var q = 'rpc_queue';\n        ch.assertQueue(q, {durable: false});\n        ch.prefetch(1);\n        ch.consume(q, function reply(msg) {\n            console.log(\"got request: %s\", msg.content.toString());\n            ch.sendToQueue(msg.properties.replyTo,\n                new Buffer('got it!'),\n                {correlationId: msg.properties.correlationId});\n            ch.ack(msg);\n        });\n    });\n});","title":"代码清单15-5"},{"location":"/chapter-15/index.html#代码清单15-6","text":"Listing 15.6 Listening for a response with the same correlation ID as the original request\nvar uuid = require('node-uuid');\namqp.connect('amqp://localhost', function(err, conn) {\n    conn.createChannel(function(err, ch) {\n        ch.assertQueue('responses', {}, function(err, q) {\n            var corr = uuid.v1();\n            ch.consume(q.queue, function(msg) {\n                if (msg.properties.correlationId === corr) {\n                    console.log('got response: %s', msg.content.toString());\n                    setTimeout(function() { conn.close(); process.exit(0) }, 500);\n                }\n            }, {noAck: true});\n            ch.sendToQueue('rpc_queue',\n                new Buffer('hello'),\n                { correlationId: corr, replyTo: q.queue });\n        });\n    });\n});","title":"代码清单15-6"},{"location":"/chapter-15/index.html#smtp","text":"S: 220 mailhost.example.com ESMTP Postfix\nC: HELO alice-workstation.example.com\nS: 250 Hello alice-workstation.example.com\nC: MAIL FROM:<alice@example.com>\nS: 250 Ok\nC: RCPT TO:<bob@example.com>\nS: 250 Ok\nC: DATA\nS: 354 End data with <CR><LF>.<CR><LF>\nC: From: \"Alice\" <alice@example.com>\nC: To: \"Bob\" <bob@example.com>\nC: Date: Fri, 23 October 2015 10:34:12 +0200\nC: Subject: lunch\nC:\nC: Hi Bob,\nC:\nC: sorry, I cannot make it, something else came up.\nC:\nC: Regards, Alice\nC: .\nS: 250 Ok, queued as 4567876345\nC: QUIT\nS: 221 Bye","title":"SMTP"},{"location":"/chapter-15/index.html#代码清单15-7","text":"Listing 15.7 Encapsulated information needed for multiple SMTP exchanges\ncase class SendEmail(\n  sender:     String,\n  recipients: List[String],\n  body:       String, correlationID: UUID,\n  replyTo: ActorRef[SendEmailResult])\ncase class SendEmailResult(\n  correlationID: UUID,\n  status:        StatusCode,\n  explanation:   Option[String]) extends Result","title":"代码清单15-7"},{"location":"/chapter-15/index.html#代码清单15-8","text":"Listing 15.8 Separating the body so it can be delivered on demand\ncase class SendEmail(\n  sender:        String,\n  recipients:    List[String],\n  correlationID: UUID,\n  replyTo:       ActorRef[SendEmailResult])(body: Source[String]) extends StreamedRequest {\n  override def payload: Source[String] = body\n}","title":"代码清单15-8"},{"location":"/chapter-15/index.html#代码清单15-9","text":"Listing 15.9 Enabling the body to be pulled by the recipient\ncase class SendEmail(sender: String, recipients: List[String],\n                     bodyLocation:  URL,\n                     correlationID: UUID,\n                     replyTo:       ActorRef[SendEmailResult])","title":"代码清单15-9"},{"location":"/chapter-16/index.html","text":"","title":"第16章——流控制模式 ·"},{"location":"/chapter-16/index.html#第16章-流控制模式","text":"","title":"第16章——流控制模式"},{"location":"/chapter-17/index.html","text":"","title":"第17章——状态管理和持久化模式 ·"},{"location":"/chapter-17/index.html#第17章-状态管理和持久化模式","text":"","title":"第17章——状态管理和持久化模式"},{"location":"/appendix-01/index.html","text":"","title":"附录A——图解反应式系统 ·"},{"location":"/appendix-01/index.html#附录a-图解反应式系统","text":"","title":"附录A——图解反应式系统"},{"location":"/appendix-02/index.html","text":"","title":"附录B——图解示例 ·"},{"location":"/appendix-02/index.html#附录b-图解示例","text":"","title":"附录B——图解示例"},{"location":"/appendix-03/index.html","text":"","title":"附录C——反应式宣言 ·"},{"location":"/appendix-03/index.html#附录c-反应式宣言","text":"","title":"附录C——反应式宣言"},{"location":"/extras.html","text":"","title":"额外指引 ·"},{"location":"/extras.html#额外指引","text":"Netty In Action In Scala","title":"额外指引"},{"location":"/errata.html","text":"","title":"勘误 ·"},{"location":"/errata.html#勘误","text":"TODO","title":"勘误"}]}